{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Android Programming Auteur : Denis Rinfret Ressources Software IntelliJ Android Studio Recommendation : install Android Studio with Jetbrains Toolbox Online Courses Kotlin for Java developers Android basics with Compose R\u00e9f\u00e9rences Kotlin tour Develop for Android Material Theme Builder Material Icons Associated Projects Available soon","title":"Android Programming"},{"location":"#android-programming","text":"Auteur : Denis Rinfret","title":"Android Programming"},{"location":"#ressources","text":"","title":"Ressources"},{"location":"#software","text":"IntelliJ Android Studio Recommendation : install Android Studio with Jetbrains Toolbox","title":"Software"},{"location":"#online-courses","text":"Kotlin for Java developers Android basics with Compose","title":"Online Courses"},{"location":"#references","text":"Kotlin tour Develop for Android Material Theme Builder Material Icons","title":"R\u00e9f\u00e9rences"},{"location":"#associated-projects","text":"Available soon","title":"Associated Projects"},{"location":"1.%20Kotlin/01-kotlin/","text":"The Kotlin Programming Language Kotlin is a modern statically typed programming language used by more than 60% of professional Android developers, which helps improve productivity, developer satisfaction, and code safety. https://developer.android.com/kotlin?hl=fr Since Google I/O 2019, Google has declared Android mobile development as Kotlin-first . This means that Google recommends Android developers use Kotlin as their first choice programming language for developing new Android applications. Kotlin offers many advantages for Android development, including null safety, code clarity and conciseness, and complete interoperability with Java, which was previously the recommended language for Android development. Android\u2019s commitment to Kotlin Kotlin Documentation Kotlin is not only used for developing Android applications, but also for server-side development, cross-platform applications, and data analysis. Details","title":"The Kotlin Programming Language"},{"location":"1.%20Kotlin/01-kotlin/#the-kotlin-programming-language","text":"Kotlin is a modern statically typed programming language used by more than 60% of professional Android developers, which helps improve productivity, developer satisfaction, and code safety. https://developer.android.com/kotlin?hl=fr Since Google I/O 2019, Google has declared Android mobile development as Kotlin-first . This means that Google recommends Android developers use Kotlin as their first choice programming language for developing new Android applications. Kotlin offers many advantages for Android development, including null safety, code clarity and conciseness, and complete interoperability with Java, which was previously the recommended language for Android development. Android\u2019s commitment to Kotlin Kotlin Documentation Kotlin is not only used for developing Android applications, but also for server-side development, cross-platform applications, and data analysis. Details","title":"The Kotlin Programming Language"},{"location":"1.%20Kotlin/02-kotlin-android/","text":"Kotlin for Android Source Android mobile development has been Kotlin-first since Google I/O in 2019. More than 50% of professional Android developers use Kotlin as their primary language, while only 30% use Java as their main language. 70% of developers whose primary language is Kotlin say that Kotlin makes them more productive. By using Kotlin for Android development, you can benefit from: Less code combined with greater readability . Spend less time writing your code and trying to understand others' code. Fewer common errors . Applications built with Kotlin are 20% less likely to crash based on Google's internal data . Kotlin support in Jetpack libraries . Jetpack Compose is Android's recommended modern toolkit for building native UI in Kotlin. KTX extensions add Kotlin language features like coroutines, extension functions, lambdas, and named parameters to existing Android libraries. Support for multiplatform development . Kotlin Multiplatform enables development not only for Android but also for iOS , backend, and web applications. Some Jetpack libraries are already multiplatform. Compose Multiplatform , JetBrains' declarative UI framework based on Kotlin and Jetpack Compose, makes it possible to share user interfaces across platforms - iOS, Android, desktop, and web. Mature language and environment . Since its creation in 2011, Kotlin has continuously evolved, not only as a language but as an entire ecosystem with robust tooling. Today, it is seamlessly integrated into Android Studio and is actively used by many companies to develop Android applications. Interoperability with Java . You can use Kotlin in combination with the Java programming language in your applications without having to migrate all your code to Kotlin. Easy to learn . Kotlin is very easy to learn, especially for Java developers. Large community . Kotlin enjoys strong support and many contributions from the worldwide community. More than 95% of the top thousand Android applications use Kotlin. Many startups and Fortune 500 companies have already developed Android applications using Kotlin, see the list on Google's Android Developers website .","title":"Kotlin for Android"},{"location":"1.%20Kotlin/02-kotlin-android/#kotlin-for-android","text":"Source Android mobile development has been Kotlin-first since Google I/O in 2019. More than 50% of professional Android developers use Kotlin as their primary language, while only 30% use Java as their main language. 70% of developers whose primary language is Kotlin say that Kotlin makes them more productive. By using Kotlin for Android development, you can benefit from: Less code combined with greater readability . Spend less time writing your code and trying to understand others' code. Fewer common errors . Applications built with Kotlin are 20% less likely to crash based on Google's internal data . Kotlin support in Jetpack libraries . Jetpack Compose is Android's recommended modern toolkit for building native UI in Kotlin. KTX extensions add Kotlin language features like coroutines, extension functions, lambdas, and named parameters to existing Android libraries. Support for multiplatform development . Kotlin Multiplatform enables development not only for Android but also for iOS , backend, and web applications. Some Jetpack libraries are already multiplatform. Compose Multiplatform , JetBrains' declarative UI framework based on Kotlin and Jetpack Compose, makes it possible to share user interfaces across platforms - iOS, Android, desktop, and web. Mature language and environment . Since its creation in 2011, Kotlin has continuously evolved, not only as a language but as an entire ecosystem with robust tooling. Today, it is seamlessly integrated into Android Studio and is actively used by many companies to develop Android applications. Interoperability with Java . You can use Kotlin in combination with the Java programming language in your applications without having to migrate all your code to Kotlin. Easy to learn . Kotlin is very easy to learn, especially for Java developers. Large community . Kotlin enjoys strong support and many contributions from the worldwide community. More than 95% of the top thousand Android applications use Kotlin. Many startups and Fortune 500 companies have already developed Android applications using Kotlin, see the list on Google's Android Developers website .","title":"Kotlin for Android"},{"location":"2.%20Android/01-intro/","text":"1. Introduction to Mobile and Android Programming Mobile programming represents an exciting and constantly evolving field in software development. It offers developers the opportunity to create applications that accompany users everywhere, transforming how we interact with technology in our daily lives. Mobile Programming Challenges Mobile application development presents unique challenges compared to traditional platforms: Limited resources : Mobile devices typically have less processing power, memory, and battery life than desktop computers. Device diversity : There is a wide variety of screen sizes, resolutions, and hardware capabilities to consider. Intermittent connectivity : Mobile applications must often function with unstable or nonexistent Internet connections. Touch interactions : The user interface must be designed for touch interactions rather than mouse and keyboard. Application lifecycle : Mobile applications can be interrupted at any time by calls, notifications, or other system events. Android vs Other Platforms Android distinguishes itself in several aspects: Open source : Unlike iOS, Android is an open-source operating system, offering more flexibility to developers. Market share : Android dominates the global smartphone market with over 70% market share. Device diversity : Android runs on a wide variety of devices from different manufacturers, unlike iOS which is limited to Apple devices. Publication process : Publishing applications on the Google Play Store is generally faster and less restrictive than on Apple's App Store. History of Android Versions 2008: Android 1.0 (API 1) 2009: Android 2.0 (Eclair, API 5) 2010: Android 2.2 (Froyo, API 8) and 2.3 (Gingerbread, API 9) 2011: Android 3.0 (Honeycomb, API 11) and 4.0 (Ice Cream Sandwich, API 14) 2012: Android 4.1 (Jelly Bean, API 16) 2013: Android 4.4 (KitKat, API 19) 2014: Android 5.0 (Lollipop, API 21) 2015: Android 6.0 (Marshmallow, API 23) 2016: Android 7.0 (Nougat, API 24) 2017: Android 8.0 (Oreo, API 26) 2018: Android 9 (Pie, API 28) 2019: Android 10 (API 29) 2020: Android 11 (API 30) 2021: Android 12 (API 31) 2022: Android 13 (API 33) 2023: Android 14 (API 34) This list highlights the progression of Android versions and their corresponding APIs. It's important to note that each new API version typically brings new features, performance improvements, and changes in how developers interact with the Android system. API numbers are particularly important for developers as they determine: The features available to the application. The application's compatibility with different Android devices. The minimum and target requirements for publishing on the Google Play Store. When developing an Android application, developers must choose a minimum API version (which determines the oldest supported devices) and a target API version (typically the most recent to take advantage of the latest features and optimizations). This constant progression of API versions underscores the importance for Android developers to stay current with the latest platform developments and adapt their applications accordingly. Classic vs Modern Android Applications Classic Applications (Java) Use of Java as the main language User interface defined in XML Use of Activities and Fragments for application structure More complex component lifecycle management Modern Applications (Kotlin with Jetpack Compose) Use of Kotlin, a more modern and concise language User interface defined declaratively with Jetpack Compose More flexible and modular application structure Simplified component lifecycle management Better performance and less boilerplate code Native support for asynchronous and reactive programming... The transition from Java to Kotlin and the adoption of Jetpack Compose represent a major evolution in Android development, offering developers more powerful tools and a more enjoyable development experience. In conclusion, Android mobile programming offers numerous opportunities and challenges. With the constant evolution of the platform and development tools, it is crucial for developers to stay up-to-date and adopt best practices to create performant and attractive applications. Android Mobile Application Development Steps Mobile application development is a complex process that involves several steps, from initial design to final deployment. Here's a detailed overview of the main steps to develop an Android mobile application, including testing and deployment phases: 1. Design and Planning Define application objectives and features Conduct market research and competitive analysis Create user interface wireframes and mockups Develop a development plan and schedule 2. Development Environment Setup Install Android Studio Configure Android SDK and necessary tools Set up version control system (e.g., Git) 3. Development Code the user interface (UI) with Jetpack Compose Implement business logic in Kotlin Integrate necessary APIs (Google Maps, payment, etc.) Manage local data storage (SharedPreferences, Room) Implement network connectivity features 4. Testing a. Unit Tests Write and execute unit tests for individual components Use JUnit and Mockito to test business logic b. Integration Tests Test interaction between different application modules Use Espresso for automated UI testing c. Manual Tests Perform functional tests on different devices and Android versions Test real-world usage scenarios d. Performance Tests Analyze application performance (CPU usage, memory, battery) Use Android Profiler to identify bottlenecks 5. Debugging and Optimization Fix bugs identified during testing Optimize application performance Improve user experience based on feedback 6. Deployment Preparation Generate a signed APK or App bundle Prepare marketing resources (icons, screenshots, descriptions) Write privacy policy and terms of use 7. Google Play Store Deployment Create a Google Play developer account Configure the application listing on Google Play console Upload APK or App bundle Define distribution countries and prices (if applicable) Submit application for review 8. Post-launch Monitoring and Maintenance Monitor installation and usage statistics Collect and analyze user feedback Respond to user comments and questions Plan and develop regular updates 9. Updates and Iterations Fix bugs reported by users Add new features based on feedback Adapt application to new Android versions and devices 10. Continuous Marketing and Promotion Implement ASO (App Store Optimization) strategies Promote the application on social media and other channels Analyze performance metrics and adjust marketing strategy This process is iterative, and many steps can overlap or be repeated as the application develops and evolves. It is crucial to remain flexible and responsive to market changes, user feedback, and technological advances throughout the application's lifecycle.","title":"1. Introduction to Mobile and Android Programming"},{"location":"2.%20Android/01-intro/#1-introduction-to-mobile-and-android-programming","text":"Mobile programming represents an exciting and constantly evolving field in software development. It offers developers the opportunity to create applications that accompany users everywhere, transforming how we interact with technology in our daily lives.","title":"1. Introduction to Mobile and Android Programming"},{"location":"2.%20Android/01-intro/#mobile-programming-challenges","text":"Mobile application development presents unique challenges compared to traditional platforms: Limited resources : Mobile devices typically have less processing power, memory, and battery life than desktop computers. Device diversity : There is a wide variety of screen sizes, resolutions, and hardware capabilities to consider. Intermittent connectivity : Mobile applications must often function with unstable or nonexistent Internet connections. Touch interactions : The user interface must be designed for touch interactions rather than mouse and keyboard. Application lifecycle : Mobile applications can be interrupted at any time by calls, notifications, or other system events.","title":"Mobile Programming Challenges"},{"location":"2.%20Android/01-intro/#android-vs-other-platforms","text":"Android distinguishes itself in several aspects: Open source : Unlike iOS, Android is an open-source operating system, offering more flexibility to developers. Market share : Android dominates the global smartphone market with over 70% market share. Device diversity : Android runs on a wide variety of devices from different manufacturers, unlike iOS which is limited to Apple devices. Publication process : Publishing applications on the Google Play Store is generally faster and less restrictive than on Apple's App Store.","title":"Android vs Other Platforms"},{"location":"2.%20Android/01-intro/#history-of-android-versions","text":"2008: Android 1.0 (API 1) 2009: Android 2.0 (Eclair, API 5) 2010: Android 2.2 (Froyo, API 8) and 2.3 (Gingerbread, API 9) 2011: Android 3.0 (Honeycomb, API 11) and 4.0 (Ice Cream Sandwich, API 14) 2012: Android 4.1 (Jelly Bean, API 16) 2013: Android 4.4 (KitKat, API 19) 2014: Android 5.0 (Lollipop, API 21) 2015: Android 6.0 (Marshmallow, API 23) 2016: Android 7.0 (Nougat, API 24) 2017: Android 8.0 (Oreo, API 26) 2018: Android 9 (Pie, API 28) 2019: Android 10 (API 29) 2020: Android 11 (API 30) 2021: Android 12 (API 31) 2022: Android 13 (API 33) 2023: Android 14 (API 34) This list highlights the progression of Android versions and their corresponding APIs. It's important to note that each new API version typically brings new features, performance improvements, and changes in how developers interact with the Android system. API numbers are particularly important for developers as they determine: The features available to the application. The application's compatibility with different Android devices. The minimum and target requirements for publishing on the Google Play Store. When developing an Android application, developers must choose a minimum API version (which determines the oldest supported devices) and a target API version (typically the most recent to take advantage of the latest features and optimizations). This constant progression of API versions underscores the importance for Android developers to stay current with the latest platform developments and adapt their applications accordingly.","title":"History of Android Versions"},{"location":"2.%20Android/01-intro/#classic-vs-modern-android-applications","text":"","title":"Classic vs Modern Android Applications"},{"location":"2.%20Android/01-intro/#classic-applications-java","text":"Use of Java as the main language User interface defined in XML Use of Activities and Fragments for application structure More complex component lifecycle management","title":"Classic Applications (Java)"},{"location":"2.%20Android/01-intro/#modern-applications-kotlin-with-jetpack-compose","text":"Use of Kotlin, a more modern and concise language User interface defined declaratively with Jetpack Compose More flexible and modular application structure Simplified component lifecycle management Better performance and less boilerplate code Native support for asynchronous and reactive programming... The transition from Java to Kotlin and the adoption of Jetpack Compose represent a major evolution in Android development, offering developers more powerful tools and a more enjoyable development experience. In conclusion, Android mobile programming offers numerous opportunities and challenges. With the constant evolution of the platform and development tools, it is crucial for developers to stay up-to-date and adopt best practices to create performant and attractive applications.","title":"Modern Applications (Kotlin with Jetpack Compose)"},{"location":"2.%20Android/01-intro/#android-mobile-application-development-steps","text":"Mobile application development is a complex process that involves several steps, from initial design to final deployment. Here's a detailed overview of the main steps to develop an Android mobile application, including testing and deployment phases:","title":"Android Mobile Application Development Steps"},{"location":"2.%20Android/01-intro/#1-design-and-planning","text":"Define application objectives and features Conduct market research and competitive analysis Create user interface wireframes and mockups Develop a development plan and schedule","title":"1. Design and Planning"},{"location":"2.%20Android/01-intro/#2-development-environment-setup","text":"Install Android Studio Configure Android SDK and necessary tools Set up version control system (e.g., Git)","title":"2. Development Environment Setup"},{"location":"2.%20Android/01-intro/#3-development","text":"Code the user interface (UI) with Jetpack Compose Implement business logic in Kotlin Integrate necessary APIs (Google Maps, payment, etc.) Manage local data storage (SharedPreferences, Room) Implement network connectivity features","title":"3. Development"},{"location":"2.%20Android/01-intro/#4-testing","text":"","title":"4. Testing"},{"location":"2.%20Android/01-intro/#a-unit-tests","text":"Write and execute unit tests for individual components Use JUnit and Mockito to test business logic","title":"a. Unit Tests"},{"location":"2.%20Android/01-intro/#b-integration-tests","text":"Test interaction between different application modules Use Espresso for automated UI testing","title":"b. Integration Tests"},{"location":"2.%20Android/01-intro/#c-manual-tests","text":"Perform functional tests on different devices and Android versions Test real-world usage scenarios","title":"c. Manual Tests"},{"location":"2.%20Android/01-intro/#d-performance-tests","text":"Analyze application performance (CPU usage, memory, battery) Use Android Profiler to identify bottlenecks","title":"d. Performance Tests"},{"location":"2.%20Android/01-intro/#5-debugging-and-optimization","text":"Fix bugs identified during testing Optimize application performance Improve user experience based on feedback","title":"5. Debugging and Optimization"},{"location":"2.%20Android/01-intro/#6-deployment-preparation","text":"Generate a signed APK or App bundle Prepare marketing resources (icons, screenshots, descriptions) Write privacy policy and terms of use","title":"6. Deployment Preparation"},{"location":"2.%20Android/01-intro/#7-google-play-store-deployment","text":"Create a Google Play developer account Configure the application listing on Google Play console Upload APK or App bundle Define distribution countries and prices (if applicable) Submit application for review","title":"7. Google Play Store Deployment"},{"location":"2.%20Android/01-intro/#8-post-launch-monitoring-and-maintenance","text":"Monitor installation and usage statistics Collect and analyze user feedback Respond to user comments and questions Plan and develop regular updates","title":"8. Post-launch Monitoring and Maintenance"},{"location":"2.%20Android/01-intro/#9-updates-and-iterations","text":"Fix bugs reported by users Add new features based on feedback Adapt application to new Android versions and devices","title":"9. Updates and Iterations"},{"location":"2.%20Android/01-intro/#10-continuous-marketing-and-promotion","text":"Implement ASO (App Store Optimization) strategies Promote the application on social media and other channels Analyze performance metrics and adjust marketing strategy This process is iterative, and many steps can overlap or be repeated as the application develops and evolves. It is crucial to remain flexible and responsive to market changes, user feedback, and technological advances throughout the application's lifecycle.","title":"10. Continuous Marketing and Promotion"},{"location":"2.%20Android/02-intro-compose/","text":"2. Introduction to Jetpack Compose Jetpack Compose is a modern toolkit for developing native user interfaces on Android. Launched by Google, it represents a major evolution in how developers create interfaces for Android applications. Motivations and History Motivations UI Development Simplification : Reduce complexity and boilerplate code associated with creating user interfaces. Declarative Approach : Allow developers to describe what they want to display rather than how to build it. Improved Performance : Optimize rendering and user interface updates. Alignment with Modern Trends : Align with modern UI development approaches like React and SwiftUI. History 2019 : Initial announcement of Jetpack Compose at Google I/O. 2020 : Release of first alpha versions for developers. July 2021 : Official launch of stable version 1.0. Since then, Compose continues to evolve with regular updates bringing new features and improvements. Companies and Organizations Using Kotlin and Compose Google : Uses Kotlin and Compose in many applications like Google Play, Google Home, and Google Drive. Reason: Improved developer productivity and alignment with Android recommendations. Netflix : Has adopted Kotlin for its Android application. Reason: Type safety, error reduction, and code expressiveness. Airbnb : Uses Kotlin in its mobile application. Reason: Interoperability with existing Java and improved code quality. Pinterest : Migrated to Kotlin for its Android development. Reason: Concise syntax and modern language features. Uber : Uses Kotlin in its mobile applications. Reason: Improved developer productivity and bug reduction. Trello : Has adopted Kotlin for its Android application. Reason: Language expressiveness and better programming practices. Evernote : Uses Kotlin in its Android application. Reason: Cleaner and more maintainable code. Basecamp : Migrated its application to Kotlin. Reason: Increased security and more pleasant syntax for developers. Corda : Blockchain platform developed entirely in Kotlin. Reason: Language robustness for critical systems. Coursera : Uses Kotlin for its mobile application. Reason: Improved code quality and development speed. These companies have chosen Kotlin and, for some, Compose, mainly for: Increased developer productivity Reduction in errors and crashes Language modernity and expressiveness Compatibility with existing Java ecosystem Improved code maintainability The growing adoption of Compose, although more recent, is motivated by its ability to simplify and accelerate the development of modern and performant user interfaces on Android. Basic Principles of a Compose Application Application Structure Composables : Functions annotated with @Composable that describe a part of the user interface. State : Data that can change over time and influences the UI (user interface). Recomposition : Process of updating the UI when state changes. Typical Components Layout : Column , Row , Box for structuring the UI. UI Elements : Text , Button , Image , etc., for displaying content. Modifiers : For customizing composable appearance and behavior. State Hoisting : Technique for managing and sharing state between components. Navigation : Management of different screens and application flow. Themes : Consistent customization of application appearance. Jetpack Compose offers several significant advantages compared to traditional Android development methods based on XML and the view system. Here are the main advantages of Jetpack Compose: Advantages of Jetpack Compose 1. Code Simplicity and Conciseness Less boilerplate code : Compose significantly reduces the amount of code needed to create complex user interfaces. More readable code : The declarative nature of Compose makes code easier to read and understand. UI code unification : No more juggling between XML and Java/Kotlin, everything is in a single language (Kotlin). 2. Faster Development Real-time preview : Developers can see UI changes instantly without having to recompile the entire application. Faster iterations : The combination of real-time preview and more concise code enables faster development iterations. 3. Declarative Approach Final state description : Developers describe what the UI should be, rather than the steps to get there. Simplified state management : Compose facilitates application state management and its synchronization with the UI. 4. Flexibility and Reusability Highly reusable components : It's easy to create reusable UI components and share them between different parts of the application. Easy customization : Components can be easily customized through modifiers and parameters. 5. Improved Performance Automatic optimizations : Compose automatically optimizes recompositions to minimize unnecessary UI updates. Efficient rendering : Compose's rendering system is designed to be more efficient than the traditional view system. 6. Better Interoperability Integration with existing views : Compose can be gradually integrated into existing applications, allowing for smooth migration. Support for existing Android libraries : Compose works well with existing Android libraries and components. 7. Simplified Testing Easier unit tests : Since composables are Kotlin functions, they are easier to unit test. Fewer UI tests needed : The declarative nature of Compose reduces the need for exhaustive UI testing. 8. Material Design Consistency Native Material Design implementation : Compose provides ready-to-use Material Design components, making it easy to create interfaces that comply with Google's guidelines. 9. Multiplatform Support Potential for multiplatform development : Although primarily for Android, Compose has the potential to be used for desktop and web application development (with Compose for Desktop and Compose for Web). 10. Reduced Learning Curve Unified concepts : Once basic concepts are mastered, it's easier to create complex interfaces. Quality documentation and resources : Google provides extensive documentation and codelabs to facilitate learning. 11. Better Animation Management Intuitive animation API : Compose offers simpler and more powerful animation APIs than traditional methods. 12. Adaptation to Different Screen Sizes Facilitated responsive design : Compose simplifies the creation of interfaces that adapt to different screen sizes, a crucial aspect for modern Android applications. In conclusion, Jetpack Compose represents a major evolution in Android development, offering a more modern, efficient, and enjoyable approach to creating user interfaces. Although there is an initial learning curve, the long-term benefits in terms of productivity, maintainability, and code quality are significant.","title":"2. Introduction to Jetpack Compose"},{"location":"2.%20Android/02-intro-compose/#2-introduction-to-jetpack-compose","text":"Jetpack Compose is a modern toolkit for developing native user interfaces on Android. Launched by Google, it represents a major evolution in how developers create interfaces for Android applications.","title":"2. Introduction to Jetpack Compose"},{"location":"2.%20Android/02-intro-compose/#motivations-and-history","text":"","title":"Motivations and History"},{"location":"2.%20Android/02-intro-compose/#motivations","text":"UI Development Simplification : Reduce complexity and boilerplate code associated with creating user interfaces. Declarative Approach : Allow developers to describe what they want to display rather than how to build it. Improved Performance : Optimize rendering and user interface updates. Alignment with Modern Trends : Align with modern UI development approaches like React and SwiftUI.","title":"Motivations"},{"location":"2.%20Android/02-intro-compose/#history","text":"2019 : Initial announcement of Jetpack Compose at Google I/O. 2020 : Release of first alpha versions for developers. July 2021 : Official launch of stable version 1.0. Since then, Compose continues to evolve with regular updates bringing new features and improvements.","title":"History"},{"location":"2.%20Android/02-intro-compose/#companies-and-organizations-using-kotlin-and-compose","text":"Google : Uses Kotlin and Compose in many applications like Google Play, Google Home, and Google Drive. Reason: Improved developer productivity and alignment with Android recommendations. Netflix : Has adopted Kotlin for its Android application. Reason: Type safety, error reduction, and code expressiveness. Airbnb : Uses Kotlin in its mobile application. Reason: Interoperability with existing Java and improved code quality. Pinterest : Migrated to Kotlin for its Android development. Reason: Concise syntax and modern language features. Uber : Uses Kotlin in its mobile applications. Reason: Improved developer productivity and bug reduction. Trello : Has adopted Kotlin for its Android application. Reason: Language expressiveness and better programming practices. Evernote : Uses Kotlin in its Android application. Reason: Cleaner and more maintainable code. Basecamp : Migrated its application to Kotlin. Reason: Increased security and more pleasant syntax for developers. Corda : Blockchain platform developed entirely in Kotlin. Reason: Language robustness for critical systems. Coursera : Uses Kotlin for its mobile application. Reason: Improved code quality and development speed. These companies have chosen Kotlin and, for some, Compose, mainly for: Increased developer productivity Reduction in errors and crashes Language modernity and expressiveness Compatibility with existing Java ecosystem Improved code maintainability The growing adoption of Compose, although more recent, is motivated by its ability to simplify and accelerate the development of modern and performant user interfaces on Android.","title":"Companies and Organizations Using Kotlin and Compose"},{"location":"2.%20Android/02-intro-compose/#basic-principles-of-a-compose-application","text":"","title":"Basic Principles of a Compose Application"},{"location":"2.%20Android/02-intro-compose/#application-structure","text":"Composables : Functions annotated with @Composable that describe a part of the user interface. State : Data that can change over time and influences the UI (user interface). Recomposition : Process of updating the UI when state changes.","title":"Application Structure"},{"location":"2.%20Android/02-intro-compose/#typical-components","text":"Layout : Column , Row , Box for structuring the UI. UI Elements : Text , Button , Image , etc., for displaying content. Modifiers : For customizing composable appearance and behavior. State Hoisting : Technique for managing and sharing state between components. Navigation : Management of different screens and application flow. Themes : Consistent customization of application appearance. Jetpack Compose offers several significant advantages compared to traditional Android development methods based on XML and the view system. Here are the main advantages of Jetpack Compose:","title":"Typical Components"},{"location":"2.%20Android/02-intro-compose/#advantages-of-jetpack-compose","text":"","title":"Advantages of Jetpack Compose"},{"location":"2.%20Android/02-intro-compose/#1-code-simplicity-and-conciseness","text":"Less boilerplate code : Compose significantly reduces the amount of code needed to create complex user interfaces. More readable code : The declarative nature of Compose makes code easier to read and understand. UI code unification : No more juggling between XML and Java/Kotlin, everything is in a single language (Kotlin).","title":"1. Code Simplicity and Conciseness"},{"location":"2.%20Android/02-intro-compose/#2-faster-development","text":"Real-time preview : Developers can see UI changes instantly without having to recompile the entire application. Faster iterations : The combination of real-time preview and more concise code enables faster development iterations.","title":"2. Faster Development"},{"location":"2.%20Android/02-intro-compose/#3-declarative-approach","text":"Final state description : Developers describe what the UI should be, rather than the steps to get there. Simplified state management : Compose facilitates application state management and its synchronization with the UI.","title":"3. Declarative Approach"},{"location":"2.%20Android/02-intro-compose/#4-flexibility-and-reusability","text":"Highly reusable components : It's easy to create reusable UI components and share them between different parts of the application. Easy customization : Components can be easily customized through modifiers and parameters.","title":"4. Flexibility and Reusability"},{"location":"2.%20Android/02-intro-compose/#5-improved-performance","text":"Automatic optimizations : Compose automatically optimizes recompositions to minimize unnecessary UI updates. Efficient rendering : Compose's rendering system is designed to be more efficient than the traditional view system.","title":"5. Improved Performance"},{"location":"2.%20Android/02-intro-compose/#6-better-interoperability","text":"Integration with existing views : Compose can be gradually integrated into existing applications, allowing for smooth migration. Support for existing Android libraries : Compose works well with existing Android libraries and components.","title":"6. Better Interoperability"},{"location":"2.%20Android/02-intro-compose/#7-simplified-testing","text":"Easier unit tests : Since composables are Kotlin functions, they are easier to unit test. Fewer UI tests needed : The declarative nature of Compose reduces the need for exhaustive UI testing.","title":"7. Simplified Testing"},{"location":"2.%20Android/02-intro-compose/#8-material-design-consistency","text":"Native Material Design implementation : Compose provides ready-to-use Material Design components, making it easy to create interfaces that comply with Google's guidelines.","title":"8. Material Design Consistency"},{"location":"2.%20Android/02-intro-compose/#9-multiplatform-support","text":"Potential for multiplatform development : Although primarily for Android, Compose has the potential to be used for desktop and web application development (with Compose for Desktop and Compose for Web).","title":"9. Multiplatform Support"},{"location":"2.%20Android/02-intro-compose/#10-reduced-learning-curve","text":"Unified concepts : Once basic concepts are mastered, it's easier to create complex interfaces. Quality documentation and resources : Google provides extensive documentation and codelabs to facilitate learning.","title":"10. Reduced Learning Curve"},{"location":"2.%20Android/02-intro-compose/#11-better-animation-management","text":"Intuitive animation API : Compose offers simpler and more powerful animation APIs than traditional methods.","title":"11. Better Animation Management"},{"location":"2.%20Android/02-intro-compose/#12-adaptation-to-different-screen-sizes","text":"Facilitated responsive design : Compose simplifies the creation of interfaces that adapt to different screen sizes, a crucial aspect for modern Android applications. In conclusion, Jetpack Compose represents a major evolution in Android development, offering a more modern, efficient, and enjoyable approach to creating user interfaces. Although there is an initial learning curve, the long-term benefits in terms of productivity, maintainability, and code quality are significant.","title":"12. Adaptation to Different Screen Sizes"},{"location":"2.%20Android/03-premi%C3%A8re-app/","text":"3. First Application with Jetpack Compose Here's a simple example of a \"Hello!\" application using Jetpack Compose. I will present the code, then explain each important element step by step. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Hello!\", modifier = Modifier.align(Alignment.Center) ) } } } } Now, let's explain the important elements of this application step by step: Explanation of Key Elements 1. Imports import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier These imports are necessary to use Jetpack Compose classes and functions. 2. Main Activity Definition class MainActivity : ComponentActivity() { // ... } MainActivity inherits from ComponentActivity , which is the recommended base class for activities using Compose. 3. onCreate Method override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // ... } This method is called when the activity is created. 4. setContent setContent { // Compose content } setContent is a Compose-specific function that defines the user interface content. Everything inside this function is Compose code. 5. Box Layout Box(modifier = Modifier.fillMaxSize()) { // Box content } Box is a layout component that allows stacking elements. Modifier.fillMaxSize() makes the Box occupy all available screen space. 6. Text Composable Text( text = \"Hello!\", modifier = Modifier.align(Alignment.Center) ) Text is a Compose component for displaying text. text = \"Hello!\" defines the text to display. Modifier.align(Alignment.Center) centers the text in the Box. Key Points to Remember Composables : In Compose, the user interface is built from composable functions (like Text ). Declarative : The code describes what should be displayed, not how to build it step by step. Modifiers : Modifier s are used to customize component appearance and behavior. Hierarchy : Components are organized hierarchically (here, Text is inside Box ). No XML : Unlike traditional Android development, there are no XML files to define the layout. This simple application displays \"Hello!\" in the center of the screen. It's an ideal starting point to begin exploring Jetpack Compose, as it illustrates the basic concepts without too much complexity. Defining Composable Functions Here's the modified example with a composable function defined for the Box , and its call in onCreate . I will then explain the modifications. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.runtime.Composable import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.tooling.preview.Preview class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HelloScreen() } } } @Composable fun HelloScreen() { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Hello World!\", modifier = Modifier.align(Alignment.Center) ) } } @Preview(showBackground = true) @Composable fun HelloPreview() { HelloScreen() } Let's now explain the modifications and their implications: Explanation of Changes 1. New HelloScreen Composable Function @Composable fun HelloScreen() { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Hello World!\", modifier = Modifier.align(Alignment.Center) ) } } This new function is annotated with @Composable , indicating it's a Jetpack Compose composable function. It encapsulates the display logic that was previously directly in setContent . This approach improves code reusability and readability. 2. Modification of onCreate override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HelloScreen() } } Instead of defining the content directly in setContent , we now call our HelloScreen composable function. This makes the onCreate code more concise and clear. 3. Adding a Preview Function @Preview(showBackground = true) @Composable fun HelloPreview() { HelloScreen() } This new function is annotated with @Preview , which allows previewing the component in Android Studio without running the application. showBackground = true adds a background to the preview for better visibility. It calls HelloScreen() , allowing you to see exactly what will be displayed in the application. Implications and Benefits of These Changes Separation of Concerns : Display logic is now separated from activity logic, which is a good programming practice. Reusability : HelloScreen can be easily reused elsewhere in the application if needed. Testability : It's easier to test HelloScreen in isolation. Preview : Adding the preview function allows developers to quickly see interface changes without having to compile and run the entire application. Modularity : This structure facilitates future addition of features or modifications to the user interface. Readability : The code is clearer and easier to understand, with each part having a well-defined role. Scalability : As the application grows, this structure makes it easy to add new components and screens. This approach is typical of development with Jetpack Compose, where the user interface is built from reusable and previewable components. It's a solid foundation for developing more complex applications while maintaining clean and organized code.","title":"3. First Application with Jetpack Compose"},{"location":"2.%20Android/03-premi%C3%A8re-app/#3-first-application-with-jetpack-compose","text":"Here's a simple example of a \"Hello!\" application using Jetpack Compose. I will present the code, then explain each important element step by step. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Hello!\", modifier = Modifier.align(Alignment.Center) ) } } } } Now, let's explain the important elements of this application step by step:","title":"3. First Application with Jetpack Compose"},{"location":"2.%20Android/03-premi%C3%A8re-app/#explanation-of-key-elements","text":"","title":"Explanation of Key Elements"},{"location":"2.%20Android/03-premi%C3%A8re-app/#1-imports","text":"import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier These imports are necessary to use Jetpack Compose classes and functions.","title":"1. Imports"},{"location":"2.%20Android/03-premi%C3%A8re-app/#2-main-activity-definition","text":"class MainActivity : ComponentActivity() { // ... } MainActivity inherits from ComponentActivity , which is the recommended base class for activities using Compose.","title":"2. Main Activity Definition"},{"location":"2.%20Android/03-premi%C3%A8re-app/#3-oncreate-method","text":"override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // ... } This method is called when the activity is created.","title":"3. onCreate Method"},{"location":"2.%20Android/03-premi%C3%A8re-app/#4-setcontent","text":"setContent { // Compose content } setContent is a Compose-specific function that defines the user interface content. Everything inside this function is Compose code.","title":"4. setContent"},{"location":"2.%20Android/03-premi%C3%A8re-app/#5-box-layout","text":"Box(modifier = Modifier.fillMaxSize()) { // Box content } Box is a layout component that allows stacking elements. Modifier.fillMaxSize() makes the Box occupy all available screen space.","title":"5. Box Layout"},{"location":"2.%20Android/03-premi%C3%A8re-app/#6-text-composable","text":"Text( text = \"Hello!\", modifier = Modifier.align(Alignment.Center) ) Text is a Compose component for displaying text. text = \"Hello!\" defines the text to display. Modifier.align(Alignment.Center) centers the text in the Box.","title":"6. Text Composable"},{"location":"2.%20Android/03-premi%C3%A8re-app/#key-points-to-remember","text":"Composables : In Compose, the user interface is built from composable functions (like Text ). Declarative : The code describes what should be displayed, not how to build it step by step. Modifiers : Modifier s are used to customize component appearance and behavior. Hierarchy : Components are organized hierarchically (here, Text is inside Box ). No XML : Unlike traditional Android development, there are no XML files to define the layout. This simple application displays \"Hello!\" in the center of the screen. It's an ideal starting point to begin exploring Jetpack Compose, as it illustrates the basic concepts without too much complexity.","title":"Key Points to Remember"},{"location":"2.%20Android/03-premi%C3%A8re-app/#defining-composable-functions","text":"Here's the modified example with a composable function defined for the Box , and its call in onCreate . I will then explain the modifications. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.Box import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.Text import androidx.compose.runtime.Composable import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.tooling.preview.Preview class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HelloScreen() } } } @Composable fun HelloScreen() { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Hello World!\", modifier = Modifier.align(Alignment.Center) ) } } @Preview(showBackground = true) @Composable fun HelloPreview() { HelloScreen() } Let's now explain the modifications and their implications:","title":"Defining Composable Functions"},{"location":"2.%20Android/03-premi%C3%A8re-app/#explanation-of-changes","text":"","title":"Explanation of Changes"},{"location":"2.%20Android/03-premi%C3%A8re-app/#1-new-helloscreen-composable-function","text":"@Composable fun HelloScreen() { Box(modifier = Modifier.fillMaxSize()) { Text( text = \"Hello World!\", modifier = Modifier.align(Alignment.Center) ) } } This new function is annotated with @Composable , indicating it's a Jetpack Compose composable function. It encapsulates the display logic that was previously directly in setContent . This approach improves code reusability and readability.","title":"1. New HelloScreen Composable Function"},{"location":"2.%20Android/03-premi%C3%A8re-app/#2-modification-of-oncreate","text":"override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { HelloScreen() } } Instead of defining the content directly in setContent , we now call our HelloScreen composable function. This makes the onCreate code more concise and clear.","title":"2. Modification of onCreate"},{"location":"2.%20Android/03-premi%C3%A8re-app/#3-adding-a-preview-function","text":"@Preview(showBackground = true) @Composable fun HelloPreview() { HelloScreen() } This new function is annotated with @Preview , which allows previewing the component in Android Studio without running the application. showBackground = true adds a background to the preview for better visibility. It calls HelloScreen() , allowing you to see exactly what will be displayed in the application.","title":"3. Adding a Preview Function"},{"location":"2.%20Android/03-premi%C3%A8re-app/#implications-and-benefits-of-these-changes","text":"Separation of Concerns : Display logic is now separated from activity logic, which is a good programming practice. Reusability : HelloScreen can be easily reused elsewhere in the application if needed. Testability : It's easier to test HelloScreen in isolation. Preview : Adding the preview function allows developers to quickly see interface changes without having to compile and run the entire application. Modularity : This structure facilitates future addition of features or modifications to the user interface. Readability : The code is clearer and easier to understand, with each part having a well-defined role. Scalability : As the application grows, this structure makes it easy to add new components and screens. This approach is typical of development with Jetpack Compose, where the user interface is built from reusable and previewable components. It's a solid foundation for developing more complex applications while maintaining clean and organized code.","title":"Implications and Benefits of These Changes"},{"location":"2.%20Android/04-hockey-v1/","text":"4. Hockey Application Version 1 This code defines a structure to represent hockey players and creates user interface components using Jetpack Compose to display these players in a list. It includes a data class for players, a function to generate sample players, and two main composable functions: one to display an individual player card and another to display a list of these cards. Detailed Explanation of Composable Functions PlayerCard @Composable fun PlayerCard(player: Player, modifier: Modifier = Modifier) { // ... } This composable function creates a card to display information about an individual player. It takes a Player object and an optional Modifier as parameters. Uses a Card component to create a card with rounded corners and a border. Inside the card, it organizes content in a Column (vertical column). The first Row (horizontal line) contains the player's image. The second Row displays the player's number and name. Components used: Card : Creates an elevated surface with shadow and content. Column : Arranges elements vertically. Row : Arranges elements horizontally. Image : Displays the player's image. Text : Displays text (player's number and name). Spacer : Creates space between elements. Modifiers used: fillMaxWidth() : Fills all available width. padding() : Adds space around elements. background() : Sets the background color. width() : Sets a specific width. PlayerList @Composable fun PlayerList(modifier: Modifier = Modifier) { LazyColumn(modifier = modifier) { items(getSamplePlayers()) { PlayerCard(player = it) } } } This composable function creates a scrollable list of player cards. It uses LazyColumn , which is optimized for displaying long lists of items. The items() function is used to dynamically generate list items from the player list returned by getSamplePlayers() . For each player in the list, it creates a PlayerCard . Main component: LazyColumn : A vertical scrolling container that only loads and displays items visible on screen, making it efficient for long lists. These two composable functions work together to create an interactive and efficient user interface for displaying a list of hockey players. PlayerCard handles the display of individual player details, while PlayerList organizes these cards in a scrollable list.","title":"4. Hockey Application Version 1"},{"location":"2.%20Android/04-hockey-v1/#4-hockey-application-version-1","text":"This code defines a structure to represent hockey players and creates user interface components using Jetpack Compose to display these players in a list. It includes a data class for players, a function to generate sample players, and two main composable functions: one to display an individual player card and another to display a list of these cards.","title":"4. Hockey Application Version 1"},{"location":"2.%20Android/04-hockey-v1/#detailed-explanation-of-composable-functions","text":"","title":"Detailed Explanation of Composable Functions"},{"location":"2.%20Android/04-hockey-v1/#playercard","text":"@Composable fun PlayerCard(player: Player, modifier: Modifier = Modifier) { // ... } This composable function creates a card to display information about an individual player. It takes a Player object and an optional Modifier as parameters. Uses a Card component to create a card with rounded corners and a border. Inside the card, it organizes content in a Column (vertical column). The first Row (horizontal line) contains the player's image. The second Row displays the player's number and name. Components used: Card : Creates an elevated surface with shadow and content. Column : Arranges elements vertically. Row : Arranges elements horizontally. Image : Displays the player's image. Text : Displays text (player's number and name). Spacer : Creates space between elements. Modifiers used: fillMaxWidth() : Fills all available width. padding() : Adds space around elements. background() : Sets the background color. width() : Sets a specific width.","title":"PlayerCard"},{"location":"2.%20Android/04-hockey-v1/#playerlist","text":"@Composable fun PlayerList(modifier: Modifier = Modifier) { LazyColumn(modifier = modifier) { items(getSamplePlayers()) { PlayerCard(player = it) } } } This composable function creates a scrollable list of player cards. It uses LazyColumn , which is optimized for displaying long lists of items. The items() function is used to dynamically generate list items from the player list returned by getSamplePlayers() . For each player in the list, it creates a PlayerCard . Main component: LazyColumn : A vertical scrolling container that only loads and displays items visible on screen, making it efficient for long lists. These two composable functions work together to create an interactive and efficient user interface for displaying a list of hockey players. PlayerCard handles the display of individual player details, while PlayerList organizes these cards in a scrollable list.","title":"PlayerList"},{"location":"2.%20Android/05-etats-evenements/","text":"5. State and Event Management Example: InputExamples Example on GitHub TextLengthCounter Function The TextLengthCounter function is a Jetpack Compose composable that creates a user interface allowing users to enter text and display its length in characters. It uses states to manage the entered text and its length, and dynamically updates the display. Here's a detailed description of the function: Function Declaration: @Composable fun TextLengthCounter(modifier: Modifier = Modifier) It's a composable function that can receive a Modifier as a parameter. State Management: var text by remember { mutableStateOf(\"\") } var length by remember { mutableIntStateOf(0) } Two state variables are created: text to store the entered text and length for the text length. remember is used to preserve these states between recompositions. Interface Structure: Column( modifier = Modifier .padding(16.dp) .fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally ) { // Column content } A Column is used to organize interface elements vertically. A padding of 16dp is applied, and the column occupies all available width. Elements are horizontally centered. Input Field: TextField( value = text, onValueChange = { text = it length = text.length }, label = { Text(\"Enter text\") }, modifier = Modifier.fillMaxWidth() ) A TextField allows users to enter text. The field value is bound to the text state. With each change, text is updated and length is recalculated. Spacing: Spacer(modifier = Modifier.height(16.dp)) Spacer s are used to add vertical space between elements. Calculate Button: Button( onClick = { length = text.length } ) { Text(\"Calculate length\") } A button allows manual recalculation of the text length. Length Display: Text(\"Text length: $length characters\") A Text displays the current text length. This function illustrates several important Jetpack Compose concepts, including state management, component reactivity, and user interface organization. It shows how to create a simple but functional interactive interface. State Management with remember and mutableStateOf In Jetpack Compose, state is a crucial concept. It represents any data that can change over time and, when changed, can trigger a recomposition of the user interface. var text by remember { mutableStateOf(\"\") } var length by remember { mutableIntStateOf(0) } Role of remember remember is a function that allows preserving an object between recompositions. Without remember , each recomposition would create a new object, losing the previous state. remember \"memorizes\" the initial object and reuses it during subsequent recompositions. Function of mutableStateOf mutableStateOf creates a MutableState<T> object that encapsulates a mutable value. When this value changes, Compose is notified and can trigger a recomposition if necessary. mutableIntStateOf is a specialized version for integers, optimized for performance. Delegation with by The by keyword is used for property delegation in Kotlin. It allows using text and length directly as if they were normal variables, while benefiting from MutableState reactivity. Lambdas and State Updates Lambdas are used to define behaviors in response to events, such as value changes or clicks. In TextField onValueChange = { text = it length = text.length } This lambda is called each time the TextField content changes. it represents the new text field value. The lambda updates text with the new value and immediately recalculates length . These updates trigger a recomposition, updating the user interface. In Button onClick = { length = text.length } This lambda is simpler, called when the button is clicked. It recalculates length based on the current value of text . While this may seem redundant here (since length is already up to date), it could be useful in more complex scenarios. Reactivity and Data Flow When the user types text, onValueChange is called. text is updated, which notifies Compose of a state change. length is also immediately updated. Compose detects these state changes and triggers a recomposition. During recomposition, the TextField displays the new text, and the Text below displays the new length. This approach ensures that the user interface always stays synchronized with the application's internal state, providing a reactive and consistent user experience. FruitSelector Function The FruitSelector function is a Jetpack Compose composable that creates a fruit selector as a dropdown menu. It allows users to choose a fruit from a predefined list and displays the selected fruit. @OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector(modifier: Modifier = Modifier) { Function Declaration - `@OptIn(ExperimentalMaterial3Api::class)` indicates the use of experimental Material 3 APIs. - It's a composable function that accepts an optional `modifier`. val fruits = listOf(\"Apple\", \"Banana\", \"Orange\", \"Strawberry\", \"Kiwi\") var expanded by remember { mutableStateOf(false) } var selectedFruit by rememberSaveable { mutableStateOf(\"\") } State Initialization fruits is a static list of fruits. expanded is a boolean state to control opening/closing the dropdown menu. selectedFruit is a state to store the selected fruit. rememberSaveable is used to preserve the selection even after a configuration change (like screen rotation). Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) { Interface Structure A Column contains all elements with 16dp padding. ExposedDropdownMenuBox is the main container for the dropdown menu. TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choose a fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults .TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() ) Selector Text Field A TextField displays the selected fruit. It is read-only ( readOnly = true ). A dropdown icon is added on the right. .menuAnchor() links this field to the dropdown menu. ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { selectedFruit = fruit expanded = false } ) } } Dropdown Menu ExposedDropdownMenu contains the list of fruits. Each fruit is represented by a DropdownMenuItem . When clicking a fruit, selectedFruit is updated and the menu closes. Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Selected fruit: $selectedFruit\") } } } Selection Display A vertical space is added. If a fruit is selected, it is displayed below the menu. Overall Operation The user sees a text field with the label \"Choose a fruit\". Clicking on the field opens a dropdown menu with the list of fruits. Selecting a fruit updates the selectedFruit state and closes the menu. The selected fruit is displayed in the text field and below it. This function illustrates several advanced Jetpack Compose concepts: Using Material 3 components to create an interactive dropdown menu. State management with remember and rememberSaveable . Creating a dynamic and reactive user interface. Using lambdas to handle user interactions. Conditional display based on state ( if (selectedFruit.isNotEmpty()) ).","title":"5. State and Event Management"},{"location":"2.%20Android/05-etats-evenements/#5-state-and-event-management","text":"","title":"5. State and Event Management"},{"location":"2.%20Android/05-etats-evenements/#example-inputexamples","text":"Example on GitHub","title":"Example: InputExamples"},{"location":"2.%20Android/05-etats-evenements/#textlengthcounter-function","text":"The TextLengthCounter function is a Jetpack Compose composable that creates a user interface allowing users to enter text and display its length in characters. It uses states to manage the entered text and its length, and dynamically updates the display. Here's a detailed description of the function:","title":"TextLengthCounter Function"},{"location":"2.%20Android/05-etats-evenements/#function-declaration","text":"@Composable fun TextLengthCounter(modifier: Modifier = Modifier) It's a composable function that can receive a Modifier as a parameter.","title":"Function Declaration:"},{"location":"2.%20Android/05-etats-evenements/#state-management","text":"var text by remember { mutableStateOf(\"\") } var length by remember { mutableIntStateOf(0) } Two state variables are created: text to store the entered text and length for the text length. remember is used to preserve these states between recompositions.","title":"State Management:"},{"location":"2.%20Android/05-etats-evenements/#interface-structure","text":"Column( modifier = Modifier .padding(16.dp) .fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally ) { // Column content } A Column is used to organize interface elements vertically. A padding of 16dp is applied, and the column occupies all available width. Elements are horizontally centered.","title":"Interface Structure:"},{"location":"2.%20Android/05-etats-evenements/#input-field","text":"TextField( value = text, onValueChange = { text = it length = text.length }, label = { Text(\"Enter text\") }, modifier = Modifier.fillMaxWidth() ) A TextField allows users to enter text. The field value is bound to the text state. With each change, text is updated and length is recalculated.","title":"Input Field:"},{"location":"2.%20Android/05-etats-evenements/#spacing","text":"Spacer(modifier = Modifier.height(16.dp)) Spacer s are used to add vertical space between elements.","title":"Spacing:"},{"location":"2.%20Android/05-etats-evenements/#calculate-button","text":"Button( onClick = { length = text.length } ) { Text(\"Calculate length\") } A button allows manual recalculation of the text length.","title":"Calculate Button:"},{"location":"2.%20Android/05-etats-evenements/#length-display","text":"Text(\"Text length: $length characters\") A Text displays the current text length. This function illustrates several important Jetpack Compose concepts, including state management, component reactivity, and user interface organization. It shows how to create a simple but functional interactive interface.","title":"Length Display:"},{"location":"2.%20Android/05-etats-evenements/#state-management-with-remember-and-mutablestateof","text":"In Jetpack Compose, state is a crucial concept. It represents any data that can change over time and, when changed, can trigger a recomposition of the user interface. var text by remember { mutableStateOf(\"\") } var length by remember { mutableIntStateOf(0) }","title":"State Management with remember and mutableStateOf"},{"location":"2.%20Android/05-etats-evenements/#role-of-remember","text":"remember is a function that allows preserving an object between recompositions. Without remember , each recomposition would create a new object, losing the previous state. remember \"memorizes\" the initial object and reuses it during subsequent recompositions.","title":"Role of remember"},{"location":"2.%20Android/05-etats-evenements/#function-of-mutablestateof","text":"mutableStateOf creates a MutableState<T> object that encapsulates a mutable value. When this value changes, Compose is notified and can trigger a recomposition if necessary. mutableIntStateOf is a specialized version for integers, optimized for performance.","title":"Function of mutableStateOf"},{"location":"2.%20Android/05-etats-evenements/#delegation-with-by","text":"The by keyword is used for property delegation in Kotlin. It allows using text and length directly as if they were normal variables, while benefiting from MutableState reactivity.","title":"Delegation with by"},{"location":"2.%20Android/05-etats-evenements/#lambdas-and-state-updates","text":"Lambdas are used to define behaviors in response to events, such as value changes or clicks.","title":"Lambdas and State Updates"},{"location":"2.%20Android/05-etats-evenements/#in-textfield","text":"onValueChange = { text = it length = text.length } This lambda is called each time the TextField content changes. it represents the new text field value. The lambda updates text with the new value and immediately recalculates length . These updates trigger a recomposition, updating the user interface.","title":"In TextField"},{"location":"2.%20Android/05-etats-evenements/#in-button","text":"onClick = { length = text.length } This lambda is simpler, called when the button is clicked. It recalculates length based on the current value of text . While this may seem redundant here (since length is already up to date), it could be useful in more complex scenarios.","title":"In Button"},{"location":"2.%20Android/05-etats-evenements/#reactivity-and-data-flow","text":"When the user types text, onValueChange is called. text is updated, which notifies Compose of a state change. length is also immediately updated. Compose detects these state changes and triggers a recomposition. During recomposition, the TextField displays the new text, and the Text below displays the new length. This approach ensures that the user interface always stays synchronized with the application's internal state, providing a reactive and consistent user experience.","title":"Reactivity and Data Flow"},{"location":"2.%20Android/05-etats-evenements/#fruitselector-function","text":"The FruitSelector function is a Jetpack Compose composable that creates a fruit selector as a dropdown menu. It allows users to choose a fruit from a predefined list and displays the selected fruit. @OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector(modifier: Modifier = Modifier) {","title":"FruitSelector Function"},{"location":"2.%20Android/05-etats-evenements/#function-declaration_1","text":"- `@OptIn(ExperimentalMaterial3Api::class)` indicates the use of experimental Material 3 APIs. - It's a composable function that accepts an optional `modifier`. val fruits = listOf(\"Apple\", \"Banana\", \"Orange\", \"Strawberry\", \"Kiwi\") var expanded by remember { mutableStateOf(false) } var selectedFruit by rememberSaveable { mutableStateOf(\"\") }","title":"Function Declaration"},{"location":"2.%20Android/05-etats-evenements/#state-initialization","text":"fruits is a static list of fruits. expanded is a boolean state to control opening/closing the dropdown menu. selectedFruit is a state to store the selected fruit. rememberSaveable is used to preserve the selection even after a configuration change (like screen rotation). Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) {","title":"State Initialization"},{"location":"2.%20Android/05-etats-evenements/#interface-structure_1","text":"A Column contains all elements with 16dp padding. ExposedDropdownMenuBox is the main container for the dropdown menu. TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choose a fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults .TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() )","title":"Interface Structure"},{"location":"2.%20Android/05-etats-evenements/#selector-text-field","text":"A TextField displays the selected fruit. It is read-only ( readOnly = true ). A dropdown icon is added on the right. .menuAnchor() links this field to the dropdown menu. ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { selectedFruit = fruit expanded = false } ) } }","title":"Selector Text Field"},{"location":"2.%20Android/05-etats-evenements/#dropdown-menu","text":"ExposedDropdownMenu contains the list of fruits. Each fruit is represented by a DropdownMenuItem . When clicking a fruit, selectedFruit is updated and the menu closes. Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Selected fruit: $selectedFruit\") } } }","title":"Dropdown Menu"},{"location":"2.%20Android/05-etats-evenements/#selection-display","text":"A vertical space is added. If a fruit is selected, it is displayed below the menu.","title":"Selection Display"},{"location":"2.%20Android/05-etats-evenements/#overall-operation","text":"The user sees a text field with the label \"Choose a fruit\". Clicking on the field opens a dropdown menu with the list of fruits. Selecting a fruit updates the selectedFruit state and closes the menu. The selected fruit is displayed in the text field and below it. This function illustrates several advanced Jetpack Compose concepts: Using Material 3 components to create an interactive dropdown menu. State management with remember and rememberSaveable . Creating a dynamic and reactive user interface. Using lambdas to handle user interactions. Conditional display based on state ( if (selectedFruit.isNotEmpty()) ).","title":"Overall Operation"},{"location":"2.%20Android/06-hockey-v2/","text":"6. Hockey Application Version 2 Explanation of PlayerListWithSearch This new version adds a search functionality to the player list. Here's a detailed explanation of the modifications: getPlayers Function fun getPlayers(name: String? = null): List<Player> = if (name == null) getSamplePlayers() else getSamplePlayers().filter { it.name.lowercase().contains(name.lowercase()) }.toList() This function allows filtering the player list based on a search criterion: If name is null , it returns all players. Otherwise, it filters the list to return only players whose name contains the search string (case-insensitive). PlayerListWithSearch Composable @Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var searchCriteria by rememberSaveable { mutableStateOf(\"\") } Column { TextField( value = searchCriteria, onValueChange = { searchCriteria = it }, modifier = modifier ) LazyColumn(modifier = modifier.fillMaxSize()) { items(getPlayers(searchCriteria)) { PlayerCard(player = it) } } } } This composable replaces PlayerList and adds search functionality: searchCriteria : Uses rememberSaveable to preserve the search state even during recompositions. mutableStateOf(\"\") initializes the search value to an empty string. Column : Vertically organizes the search field and player list. TextField : Allows users to enter a search criterion. value = searchCriteria displays the current value. onValueChange = { searchCriteria = it } updates searchCriteria with each change. LazyColumn : Similar to the previous version, but now uses getPlayers(searchCriteria) . This dynamically filters the player list based on the search criterion. items : Creates a PlayerCard for each filtered player. This new version offers a more interactive user experience, allowing users to search for specific players in the list. The list updates automatically with each change in the search field text, thanks to the use of state ( searchCriteria ) and Jetpack Compose's automatic recomposition. Connections between TextField , mutableStateOf , onValueChange , and getPlayers() 1. mutableStateOf and Composable State var searchCriteria by rememberSaveable { mutableStateOf(\"\") } mutableStateOf(\"\") creates a mutable state initialized with an empty string. rememberSaveable allows preserving this state even during recompositions or configuration changes. by is used to delegate the property, allowing direct access and modification of searchCriteria . 2. TextField and onValueChange TextField( value = searchCriteria, onValueChange = { searchCriteria = it }, modifier = modifier ) value = searchCriteria : The TextField displays the current value of searchCriteria . onValueChange = { searchCriteria = it } : When the user types in the field: it represents the new field value. This new value is assigned to searchCriteria . This triggers a recomposition of the composable. 3. Connection with getPlayers() LazyColumn(modifier = modifier.fillMaxSize()) { items(getPlayers(searchCriteria)) { PlayerCard(player = it) } } getPlayers(searchCriteria) is called with the current value of searchCriteria . Each time searchCriteria changes: getPlayers() is recalled with the new value. The player list is filtered based on this new value. LazyColumn recomposes with the new filtered list. 4. Data Flow and Recomposition The user types in the TextField . onValueChange is called, updating searchCriteria . Updating searchCriteria triggers a recomposition. During recomposition: TextField displays the new value of searchCriteria . getPlayers(searchCriteria) is called with the new value. LazyColumn recomposes with the new filtered list. This reactive architecture enables real-time updates of the user interface. Each keystroke in the search field triggers a chain of reactions that results in the filtered display of players, providing a smooth and reactive user experience.","title":"6. Hockey Application Version 2"},{"location":"2.%20Android/06-hockey-v2/#6-hockey-application-version-2","text":"","title":"6. Hockey Application Version 2"},{"location":"2.%20Android/06-hockey-v2/#explanation-of-playerlistwithsearch","text":"This new version adds a search functionality to the player list. Here's a detailed explanation of the modifications:","title":"Explanation of PlayerListWithSearch"},{"location":"2.%20Android/06-hockey-v2/#getplayers-function","text":"fun getPlayers(name: String? = null): List<Player> = if (name == null) getSamplePlayers() else getSamplePlayers().filter { it.name.lowercase().contains(name.lowercase()) }.toList() This function allows filtering the player list based on a search criterion: If name is null , it returns all players. Otherwise, it filters the list to return only players whose name contains the search string (case-insensitive).","title":"getPlayers Function"},{"location":"2.%20Android/06-hockey-v2/#playerlistwithsearch-composable","text":"@Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var searchCriteria by rememberSaveable { mutableStateOf(\"\") } Column { TextField( value = searchCriteria, onValueChange = { searchCriteria = it }, modifier = modifier ) LazyColumn(modifier = modifier.fillMaxSize()) { items(getPlayers(searchCriteria)) { PlayerCard(player = it) } } } } This composable replaces PlayerList and adds search functionality: searchCriteria : Uses rememberSaveable to preserve the search state even during recompositions. mutableStateOf(\"\") initializes the search value to an empty string. Column : Vertically organizes the search field and player list. TextField : Allows users to enter a search criterion. value = searchCriteria displays the current value. onValueChange = { searchCriteria = it } updates searchCriteria with each change. LazyColumn : Similar to the previous version, but now uses getPlayers(searchCriteria) . This dynamically filters the player list based on the search criterion. items : Creates a PlayerCard for each filtered player. This new version offers a more interactive user experience, allowing users to search for specific players in the list. The list updates automatically with each change in the search field text, thanks to the use of state ( searchCriteria ) and Jetpack Compose's automatic recomposition.","title":"PlayerListWithSearch Composable"},{"location":"2.%20Android/06-hockey-v2/#connections-between-textfield-mutablestateof-onvaluechange-and-getplayers","text":"","title":"Connections between TextField, mutableStateOf, onValueChange, and getPlayers()"},{"location":"2.%20Android/06-hockey-v2/#1-mutablestateof-and-composable-state","text":"var searchCriteria by rememberSaveable { mutableStateOf(\"\") } mutableStateOf(\"\") creates a mutable state initialized with an empty string. rememberSaveable allows preserving this state even during recompositions or configuration changes. by is used to delegate the property, allowing direct access and modification of searchCriteria .","title":"1. mutableStateOf and Composable State"},{"location":"2.%20Android/06-hockey-v2/#2-textfield-and-onvaluechange","text":"TextField( value = searchCriteria, onValueChange = { searchCriteria = it }, modifier = modifier ) value = searchCriteria : The TextField displays the current value of searchCriteria . onValueChange = { searchCriteria = it } : When the user types in the field: it represents the new field value. This new value is assigned to searchCriteria . This triggers a recomposition of the composable.","title":"2. TextField and onValueChange"},{"location":"2.%20Android/06-hockey-v2/#3-connection-with-getplayers","text":"LazyColumn(modifier = modifier.fillMaxSize()) { items(getPlayers(searchCriteria)) { PlayerCard(player = it) } } getPlayers(searchCriteria) is called with the current value of searchCriteria . Each time searchCriteria changes: getPlayers() is recalled with the new value. The player list is filtered based on this new value. LazyColumn recomposes with the new filtered list.","title":"3. Connection with getPlayers()"},{"location":"2.%20Android/06-hockey-v2/#4-data-flow-and-recomposition","text":"The user types in the TextField . onValueChange is called, updating searchCriteria . Updating searchCriteria triggers a recomposition. During recomposition: TextField displays the new value of searchCriteria . getPlayers(searchCriteria) is called with the new value. LazyColumn recomposes with the new filtered list. This reactive architecture enables real-time updates of the user interface. Each keystroke in the search field triggers a chain of reactions that results in the filtered display of players, providing a smooth and reactive user experience.","title":"4. Data Flow and Recomposition"},{"location":"2.%20Android/07-orientation/","text":"7. Screen Orientation To detect screen orientation (portrait or landscape) with Jetpack Compose, you can use the LocalConfiguration composable. Here's how to do it: 1- Import the necessary dependencies: import android.content.res.Configuration import androidx.compose.runtime.Composable import androidx.compose.ui.platform.LocalConfiguration 2- Use LocalConfiguration in your composable to get the current configuration: @Composable fun MyScreen() { val configuration = LocalConfiguration.current when (configuration.orientation) { Configuration.ORIENTATION_LANDSCAPE -> { // Code for landscape orientation Text(\"Screen is in landscape mode\") } else -> { // Code for portrait orientation Text(\"Screen is in portrait mode\") } } } 3- To observe orientation changes, you can use a State : @Composable fun OrientationAwareLayout() { val configuration = LocalConfiguration.current val orientation by remember { mutableStateOf(configuration.orientation) } LaunchedEffect(configuration) { snapshotFlow { configuration.orientation } .collect { orientation = it } } when (orientation) { Configuration.ORIENTATION_LANDSCAPE -> { // Layout for landscape mode } else -> { // Layout for portrait mode } } } This approach allows your composable to automatically recompose when the orientation changes. By using these methods, you can create responsive user interfaces that adapt to screen orientation. This is particularly useful for optimizing user experience across different devices and screen configurations. Citations: https://developer.android.com/guide/practices/device-compatibility-mode?hl=fr https://www.geeksforgeeks.org/detect-screen-orientation-in-android-using-jetpack-compose/ https://blog.ippon.fr/2023/04/28/developper-app-jetpack-compose-smartphones-pliables/ https://developer.android.com/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling?hl=fr https://developer.android.com/develop/ui/compose/touch-input/stylus-input/advanced-stylus-features?hl=fr https://stackoverflow.com/questions/64753944/orientation-on-jetpack-compose https://appmaster.io/fr/blog/comment-creer-une-interface-utilisateur-adaptative-avec-jetpack-compose Complete Example import android.content.res.Configuration import androidx.compose.foundation.layout.* import androidx.compose.material3.Button import androidx.compose.material3.ExperimentalMaterial3Api import androidx.compose.material3.Text import androidx.compose.material3.TextField import androidx.compose.runtime.* import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.platform.LocalConfiguration import androidx.compose.ui.unit.dp @OptIn(ExperimentalMaterial3Api::class) @Composable fun OrientationResponsiveLayout(modifier: Modifier = Modifier) { var text1 by remember { mutableStateOf(\"\") } var text2 by remember { mutableStateOf(\"\") } val configuration = LocalConfiguration.current val isLandscape = configuration.orientation == Configuration.ORIENTATION_LANDSCAPE if (isLandscape) { Column( modifier = modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally ) { Row( modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween ) { TextField( value = text1, onValueChange = { text1 = it }, label = { Text(\"Field 1\") }, modifier = Modifier.weight(1f).padding(end = 8.dp) ) TextField( value = text2, onValueChange = { text2 = it }, label = { Text(\"Field 2\") }, modifier = Modifier.weight(1f).padding(start = 8.dp) ) } Spacer(modifier = Modifier.height(16.dp)) Button(onClick = { /* Button action */ }) { Text(\"Validate\") } } } else { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(16.dp) ) { TextField( value = text1, onValueChange = { text1 = it }, label = { Text(\"Field 1\") }, modifier = Modifier.fillMaxWidth() ) TextField( value = text2, onValueChange = { text2 = it }, label = { Text(\"Field 2\") }, modifier = Modifier.fillMaxWidth() ) Button(onClick = { /* Button action */ }) { Text(\"Validate\") } } } } In this example: We use LocalConfiguration.current to get the current screen configuration. We check if the orientation is in landscape mode by comparing configuration.orientation with Configuration.ORIENTATION_LANDSCAPE . In portrait mode (default): We use a Column to vertically arrange two TextField s and a Button . Elements are evenly spaced using verticalArrangement = Arrangement.spacedBy(16.dp) . In landscape mode: We use a main Column for the overall layout. Inside, we use a Row to place the two TextField s side by side. The Button is placed below the Row with a Spacer to add spacing. The TextField s use Modifier.weight(1f) in landscape mode to occupy equal space in the Row . We use remember and mutableStateOf to manage the text fields' state, allowing users to interact with them. This composable will automatically adapt to the screen orientation, providing an optimized layout for both portrait and landscape modes. It demonstrates how to create responsive user interfaces that adapt to different screen configurations using Jetpack Compose. Citations: https://developer.android.com/develop/ui/compose/layouts/adaptive https://www.blog.finotes.com/post/creating-responsive-layouts-in-android-using-jetpack-compose https://stackoverflow.com/questions/67157309/how-to-create-responsive-layouts-with-jetpack-compose https://composables.com/jetpack-compose-tutorials/responsive-layout https://www.geeksforgeeks.org/detect-screen-orientation-in-android-using-jetpack-compose/ https://eevis.codes/blog/2024-07-18/dont-lock-the-screen-orientation-handling-orientation-in-compose/","title":"7. Screen Orientation"},{"location":"2.%20Android/07-orientation/#7-screen-orientation","text":"To detect screen orientation (portrait or landscape) with Jetpack Compose, you can use the LocalConfiguration composable. Here's how to do it: 1- Import the necessary dependencies: import android.content.res.Configuration import androidx.compose.runtime.Composable import androidx.compose.ui.platform.LocalConfiguration 2- Use LocalConfiguration in your composable to get the current configuration: @Composable fun MyScreen() { val configuration = LocalConfiguration.current when (configuration.orientation) { Configuration.ORIENTATION_LANDSCAPE -> { // Code for landscape orientation Text(\"Screen is in landscape mode\") } else -> { // Code for portrait orientation Text(\"Screen is in portrait mode\") } } } 3- To observe orientation changes, you can use a State : @Composable fun OrientationAwareLayout() { val configuration = LocalConfiguration.current val orientation by remember { mutableStateOf(configuration.orientation) } LaunchedEffect(configuration) { snapshotFlow { configuration.orientation } .collect { orientation = it } } when (orientation) { Configuration.ORIENTATION_LANDSCAPE -> { // Layout for landscape mode } else -> { // Layout for portrait mode } } } This approach allows your composable to automatically recompose when the orientation changes. By using these methods, you can create responsive user interfaces that adapt to screen orientation. This is particularly useful for optimizing user experience across different devices and screen configurations. Citations: https://developer.android.com/guide/practices/device-compatibility-mode?hl=fr https://www.geeksforgeeks.org/detect-screen-orientation-in-android-using-jetpack-compose/ https://blog.ippon.fr/2023/04/28/developper-app-jetpack-compose-smartphones-pliables/ https://developer.android.com/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling?hl=fr https://developer.android.com/develop/ui/compose/touch-input/stylus-input/advanced-stylus-features?hl=fr https://stackoverflow.com/questions/64753944/orientation-on-jetpack-compose https://appmaster.io/fr/blog/comment-creer-une-interface-utilisateur-adaptative-avec-jetpack-compose","title":"7. Screen Orientation"},{"location":"2.%20Android/07-orientation/#complete-example","text":"import android.content.res.Configuration import androidx.compose.foundation.layout.* import androidx.compose.material3.Button import androidx.compose.material3.ExperimentalMaterial3Api import androidx.compose.material3.Text import androidx.compose.material3.TextField import androidx.compose.runtime.* import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.platform.LocalConfiguration import androidx.compose.ui.unit.dp @OptIn(ExperimentalMaterial3Api::class) @Composable fun OrientationResponsiveLayout(modifier: Modifier = Modifier) { var text1 by remember { mutableStateOf(\"\") } var text2 by remember { mutableStateOf(\"\") } val configuration = LocalConfiguration.current val isLandscape = configuration.orientation == Configuration.ORIENTATION_LANDSCAPE if (isLandscape) { Column( modifier = modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally ) { Row( modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween ) { TextField( value = text1, onValueChange = { text1 = it }, label = { Text(\"Field 1\") }, modifier = Modifier.weight(1f).padding(end = 8.dp) ) TextField( value = text2, onValueChange = { text2 = it }, label = { Text(\"Field 2\") }, modifier = Modifier.weight(1f).padding(start = 8.dp) ) } Spacer(modifier = Modifier.height(16.dp)) Button(onClick = { /* Button action */ }) { Text(\"Validate\") } } } else { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(16.dp) ) { TextField( value = text1, onValueChange = { text1 = it }, label = { Text(\"Field 1\") }, modifier = Modifier.fillMaxWidth() ) TextField( value = text2, onValueChange = { text2 = it }, label = { Text(\"Field 2\") }, modifier = Modifier.fillMaxWidth() ) Button(onClick = { /* Button action */ }) { Text(\"Validate\") } } } } In this example: We use LocalConfiguration.current to get the current screen configuration. We check if the orientation is in landscape mode by comparing configuration.orientation with Configuration.ORIENTATION_LANDSCAPE . In portrait mode (default): We use a Column to vertically arrange two TextField s and a Button . Elements are evenly spaced using verticalArrangement = Arrangement.spacedBy(16.dp) . In landscape mode: We use a main Column for the overall layout. Inside, we use a Row to place the two TextField s side by side. The Button is placed below the Row with a Spacer to add spacing. The TextField s use Modifier.weight(1f) in landscape mode to occupy equal space in the Row . We use remember and mutableStateOf to manage the text fields' state, allowing users to interact with them. This composable will automatically adapt to the screen orientation, providing an optimized layout for both portrait and landscape modes. It demonstrates how to create responsive user interfaces that adapt to different screen configurations using Jetpack Compose. Citations: https://developer.android.com/develop/ui/compose/layouts/adaptive https://www.blog.finotes.com/post/creating-responsive-layouts-in-android-using-jetpack-compose https://stackoverflow.com/questions/67157309/how-to-create-responsive-layouts-with-jetpack-compose https://composables.com/jetpack-compose-tutorials/responsive-layout https://www.geeksforgeeks.org/detect-screen-orientation-in-android-using-jetpack-compose/ https://eevis.codes/blog/2024-07-18/dont-lock-the-screen-orientation-handling-orientation-in-compose/","title":"Complete Example"},{"location":"2.%20Android/08-hockey-v3/","text":"8. Hockey Application Version 3 Different Versions of PlayerListWithSearch Previous Version @Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } Column(modifier = modifier) { Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { TextField( value = nameSearch, label = { Text(text = \"Name\") }, onValueChange = { nameSearch = it }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Number\") }, onValueChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) } LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } } } General Description This code defines a composable function named PlayerListWithSearch that creates a user interface to display a list of hockey players with search functionality. The interface includes two text fields for searching (one for name and one for number) and a scrollable list of players matching the search criteria. Detailed Description 1- Function Declaration: @Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) It's a composable function that accepts an optional modifier as a parameter. 2- State Variables: var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } nameSearch : A string to store the name search. numberSearch : A nullable integer to store the number search. These variables use rememberSaveable to preserve their state even after reconfiguration. 3- Main Structure: Column(modifier = modifier) { // Content } Uses a Column as the main container with the modifier passed as parameter. 4- Search Fields: Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { // Text fields } An inner Column with padding to contain the search fields. 5- Name Search Field: TextField( value = nameSearch, label = { Text(text = \"Name\") }, onValueChange = { nameSearch = it }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) A TextField for name search. The value is bound to nameSearch . The label displays \"Name\". onValueChange updates nameSearch with the new value. 6- Number Search Field: TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Number\") }, onValueChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) A TextField for number search. The displayed value is the string conversion of numberSearch (or empty string if null). The label displays \"Number\". onValueChange attempts to convert the input to an integer, keeping the previous value if conversion fails. 7- Player List: LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } Uses a LazyColumn to efficiently display a potentially long list of players. getPlayers(nameSearch, numberSearch) is called to get the filtered list of players. Each player is displayed using a HockeyPlayerCard component. This code creates an interactive user interface allowing users to search for hockey players by name and number, with dynamic updating of the displayed list based on search criteria. New Version @Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } Column(modifier = modifier) { SearchTextFields( nameSearch = nameSearch, onNameChange = { nameSearch = it }, numberSearch = numberSearch, onNumberChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }) LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } } } @Composable private fun SearchTextFields( nameSearch: String, onNameChange: (String) -> Unit, numberSearch: Int?, onNumberChange: (String) -> Unit, ) { Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { TextField( value = nameSearch, label = { Text(text = \"Name\") }, onValueChange = onNameChange, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Number\") }, onValueChange = onNumberChange, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) } } This refactoring illustrates how to improve code structure and reusability in Jetpack Compose. Here's a detailed explanation of the transition between the two versions, focusing on state management and lambda functions: Creation of the new SearchTextFields composable: A new private composable was created to encapsulate the search fields logic. This improves code readability and reusability. Parameters of the new composable: nameSearch: String : The current value of the name search. onNameChange: (String) -> Unit : A lambda function to handle name changes. numberSearch: Int? : The current value of the number search. onNumberChange: (String) -> Unit : A lambda function to handle number changes. Passing state variables: In PlayerListWithSearch , state variables nameSearch and numberSearch are passed directly to SearchTextFields . This allows SearchTextFields to use these values without owning or modifying them directly. Passing lambda functions: For onNameChange , a simple lambda is passed: { nameSearch = it } . This lambda directly updates the nameSearch state variable. For onNumberChange , the conversion logic is passed as a lambda: kotlin { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch } This lambda handles the string to integer conversion and updating numberSearch . Usage in SearchTextFields : The TextField s now use the passed parameters instead of directly accessing state variables. value = nameSearch and value = (numberSearch ?: \"\").toString() use the passed values. onValueChange = onNameChange and onValueChange = onNumberChange use the passed lambdas. Advantages of this approach: Separation of concerns: SearchTextFields only handles display and input collection. State hoisting: State remains in the parent component, making SearchTextFields more flexible and reusable. Improved testability: It's easier to test SearchTextFields independently. Implications for state management: State ( nameSearch and numberSearch ) is still managed in PlayerListWithSearch . SearchTextFields becomes a stateless component, only reflecting the state passed to it. This refactoring is an excellent example of how to apply the \"state hoisting\" principle in Jetpack Compose, by elevating state and state modification functions to the parent component. This makes the code more modular, easier to maintain and test, while maintaining a clear separation of responsibilities between components.","title":"8. Hockey Application Version 3"},{"location":"2.%20Android/08-hockey-v3/#8-hockey-application-version-3","text":"","title":"8. Hockey Application Version 3"},{"location":"2.%20Android/08-hockey-v3/#different-versions-of-playerlistwithsearch","text":"","title":"Different Versions of PlayerListWithSearch"},{"location":"2.%20Android/08-hockey-v3/#previous-version","text":"@Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } Column(modifier = modifier) { Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { TextField( value = nameSearch, label = { Text(text = \"Name\") }, onValueChange = { nameSearch = it }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Number\") }, onValueChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) } LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } } }","title":"Previous Version"},{"location":"2.%20Android/08-hockey-v3/#general-description","text":"This code defines a composable function named PlayerListWithSearch that creates a user interface to display a list of hockey players with search functionality. The interface includes two text fields for searching (one for name and one for number) and a scrollable list of players matching the search criteria.","title":"General Description"},{"location":"2.%20Android/08-hockey-v3/#detailed-description","text":"1- Function Declaration: @Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) It's a composable function that accepts an optional modifier as a parameter. 2- State Variables: var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } nameSearch : A string to store the name search. numberSearch : A nullable integer to store the number search. These variables use rememberSaveable to preserve their state even after reconfiguration. 3- Main Structure: Column(modifier = modifier) { // Content } Uses a Column as the main container with the modifier passed as parameter. 4- Search Fields: Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { // Text fields } An inner Column with padding to contain the search fields. 5- Name Search Field: TextField( value = nameSearch, label = { Text(text = \"Name\") }, onValueChange = { nameSearch = it }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) A TextField for name search. The value is bound to nameSearch . The label displays \"Name\". onValueChange updates nameSearch with the new value. 6- Number Search Field: TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Number\") }, onValueChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) A TextField for number search. The displayed value is the string conversion of numberSearch (or empty string if null). The label displays \"Number\". onValueChange attempts to convert the input to an integer, keeping the previous value if conversion fails. 7- Player List: LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } Uses a LazyColumn to efficiently display a potentially long list of players. getPlayers(nameSearch, numberSearch) is called to get the filtered list of players. Each player is displayed using a HockeyPlayerCard component. This code creates an interactive user interface allowing users to search for hockey players by name and number, with dynamic updating of the displayed list based on search criteria.","title":"Detailed Description"},{"location":"2.%20Android/08-hockey-v3/#new-version","text":"@Composable fun PlayerListWithSearch(modifier: Modifier = Modifier) { var nameSearch by rememberSaveable { mutableStateOf(\"\") } var numberSearch: Int? by rememberSaveable { mutableStateOf(null) } Column(modifier = modifier) { SearchTextFields( nameSearch = nameSearch, onNameChange = { nameSearch = it }, numberSearch = numberSearch, onNumberChange = { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch }) LazyColumn(modifier = Modifier.fillMaxSize()) { items(getPlayers(nameSearch, numberSearch)) { HockeyPlayerCard(player = it) } } } } @Composable private fun SearchTextFields( nameSearch: String, onNameChange: (String) -> Unit, numberSearch: Int?, onNumberChange: (String) -> Unit, ) { Column(modifier = Modifier.padding(top = 20.dp, bottom = 20.dp)) { TextField( value = nameSearch, label = { Text(text = \"Name\") }, onValueChange = onNameChange, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) TextField( value = (numberSearch ?: \"\").toString(), label = { Text(text = \"Number\") }, onValueChange = onNumberChange, modifier = Modifier .fillMaxWidth() .padding(start = 20.dp, end = 20.dp) ) } } This refactoring illustrates how to improve code structure and reusability in Jetpack Compose. Here's a detailed explanation of the transition between the two versions, focusing on state management and lambda functions: Creation of the new SearchTextFields composable: A new private composable was created to encapsulate the search fields logic. This improves code readability and reusability. Parameters of the new composable: nameSearch: String : The current value of the name search. onNameChange: (String) -> Unit : A lambda function to handle name changes. numberSearch: Int? : The current value of the number search. onNumberChange: (String) -> Unit : A lambda function to handle number changes. Passing state variables: In PlayerListWithSearch , state variables nameSearch and numberSearch are passed directly to SearchTextFields . This allows SearchTextFields to use these values without owning or modifying them directly. Passing lambda functions: For onNameChange , a simple lambda is passed: { nameSearch = it } . This lambda directly updates the nameSearch state variable. For onNumberChange , the conversion logic is passed as a lambda: kotlin { numberSearch = if (it.isEmpty()) null else it.toIntOrNull() ?: numberSearch } This lambda handles the string to integer conversion and updating numberSearch . Usage in SearchTextFields : The TextField s now use the passed parameters instead of directly accessing state variables. value = nameSearch and value = (numberSearch ?: \"\").toString() use the passed values. onValueChange = onNameChange and onValueChange = onNumberChange use the passed lambdas. Advantages of this approach: Separation of concerns: SearchTextFields only handles display and input collection. State hoisting: State remains in the parent component, making SearchTextFields more flexible and reusable. Improved testability: It's easier to test SearchTextFields independently. Implications for state management: State ( nameSearch and numberSearch ) is still managed in PlayerListWithSearch . SearchTextFields becomes a stateless component, only reflecting the state passed to it. This refactoring is an excellent example of how to apply the \"state hoisting\" principle in Jetpack Compose, by elevating state and state modification functions to the parent component. This makes the code more modular, easier to maintain and test, while maintaining a clear separation of responsibilities between components.","title":"New Version"},{"location":"2.%20Android/09-etats-evenements-v2/","text":"9. State and Event Management Example: InputExamples Example on GitHub First Version @OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector(modifier: Modifier = Modifier) { val fruits = listOf(\"Apple\", \"Banana\", \"Orange\", \"Strawberry\", \"Kiwi\") var expanded by remember { mutableStateOf(false) } var selectedFruit by remember { mutableStateOf(\"\") } Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) { TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choose a fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() ) ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { selectedFruit = fruit expanded = false } ) } } } Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Selected fruit: $selectedFruit\") } } } @Composable fun App(modifier: Modifier = Modifier) { Column(modifier = modifier) { TextLengthCounter() Spacer(modifier = Modifier.height(100.dp)) FruitSelector() } } General Description FruitSelector : This is a composable function that creates a fruit selector in the form of a dropdown menu. App : This is the main composable function that structures the application's user interface by combining different components. Focus on FruitSelector The FruitSelector function is a Jetpack Compose component that creates a dropdown menu allowing users to select a fruit from a predefined list. Here are its main features: Fruit List : A static list of fruits is defined at the beginning of the function. States : expanded : A boolean state that controls whether the dropdown menu is open or closed. selectedFruit : A state that stores the currently selected fruit. User Interface : Uses ExposedDropdownMenuBox to create the dropdown menu container. Displays a TextField that serves as a trigger to open the menu. This field is read-only and displays the selected fruit. The dropdown menu ( ExposedDropdownMenu ) contains the list of fruits, each represented by a DropdownMenuItem . Interaction : When a fruit is selected, the menu closes and the chosen fruit is displayed in the TextField. Additional text appears below to confirm the selected fruit. Layout : Uses a Column to vertically organize elements. Adds spacing and padding to improve appearance. Customization : Accepts a modifier parameter to allow additional customization if needed. This function demonstrates the use of several important Jetpack Compose concepts, such as state management, Material 3 UI components, and the creation of interactive components. It provides an intuitive user interface for selecting items from a list, which is a common functionality in many applications. Second Version @OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector( modifier: Modifier = Modifier, fruits: List<String>, selectedFruit: String, onFruitSelected: (String) -> Unit = {} ) { var expanded by remember { mutableStateOf(false) } Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) { TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choose a fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults .TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() ) ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { onFruitSelected(fruit) expanded = false } ) } } } Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Selected fruit: $selectedFruit\") } } } @Composable fun App(modifier: Modifier = Modifier) { var selectedFruit1 by rememberSaveable { mutableStateOf(\"\") } var selectedFruit2 by rememberSaveable { mutableStateOf(\"\") } Column(modifier = modifier) { TextLengthCounter() Spacer(modifier = Modifier.height(100.dp)) FruitSelector( fruits = listOf(\"Apple\", \"Banana\", \"Orange\", \"Strawberry\", \"Kiwi\"), selectedFruit = selectedFruit1, onFruitSelected = { fruit -> selectedFruit1 = fruit } ) Spacer(modifier = Modifier.height(10.dp)) FruitSelector( fruits = listOf(\"Pear\", \"Mango\", \"Orange\", \"Blueberry\", \"Grapefruit\"), selectedFruit = selectedFruit2, onFruitSelected = { fruit -> selectedFruit2 = fruit } ) Spacer(modifier = Modifier.height(10.dp)) Text(\"Selected fruit 1: ${selectedFruit1 ?: \"None\"}\") Text(\"Selected fruit 2: ${selectedFruit2 ?: \"None\"}\") } } This new version of the application demonstrates significant refactoring, primarily focused on state hoisting and component reusability. Let's examine the changes and their implications in detail: FruitSelector Refactoring State Hoisting : selectedFruit is no longer managed inside FruitSelector . It's now passed as a parameter. A new onFruitSelected function is added as a parameter to handle selection changes. Added Parameters : fruits: List<String> : The fruit list is now a parameter, making the component more flexible. selectedFruit: String : The selected fruit state is passed as a parameter. onFruitSelected: (String) -> Unit : A callback function to handle fruit selection. Remaining Local State : expanded remains a local state as it only concerns the dropdown menu display. Changes in App State Management : Two new state variables are introduced: selectedFruit1 and selectedFruit2 . These states are created with rememberSaveable to persist across recompositions and configuration changes. FruitSelector Usage : Two instances of FruitSelector are created, each with its own fruit list and state. The state and update function are passed to each FruitSelector . Selection Display : Selected fruits are displayed at the bottom of the App, demonstrating that state is now managed at the top level. Benefits of this Refactoring Reusability : FruitSelector can now be used multiple times with different fruit lists. Separation of Concerns : State management is separated from display, making the code more modular. Increased Control : The App now has full control over selection states, allowing for more complex interactions if needed. Improved Testability : It's easier to test FruitSelector as its behavior depends entirely on passed props. Flexibility : The fruit list can be dynamic, coming from an API or database, for example. Focus on State Variables In App , selectedFruit1 and selectedFruit2 are state variables created with rememberSaveable . This means they will retain their value even during configuration changes (like screen rotation). In FruitSelector , only expanded remains a local state variable, as it only concerns the internal display of the component. This refactoring illustrates important Jetpack Compose principles, particularly state hoisting and creating reusable, independent components. It allows for better application state management and greater flexibility in building the user interface.","title":"9. State and Event Management"},{"location":"2.%20Android/09-etats-evenements-v2/#9-state-and-event-management","text":"","title":"9. State and Event Management"},{"location":"2.%20Android/09-etats-evenements-v2/#example-inputexamples","text":"Example on GitHub","title":"Example: InputExamples"},{"location":"2.%20Android/09-etats-evenements-v2/#first-version","text":"@OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector(modifier: Modifier = Modifier) { val fruits = listOf(\"Apple\", \"Banana\", \"Orange\", \"Strawberry\", \"Kiwi\") var expanded by remember { mutableStateOf(false) } var selectedFruit by remember { mutableStateOf(\"\") } Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) { TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choose a fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() ) ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { selectedFruit = fruit expanded = false } ) } } } Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Selected fruit: $selectedFruit\") } } } @Composable fun App(modifier: Modifier = Modifier) { Column(modifier = modifier) { TextLengthCounter() Spacer(modifier = Modifier.height(100.dp)) FruitSelector() } }","title":"First Version"},{"location":"2.%20Android/09-etats-evenements-v2/#general-description","text":"FruitSelector : This is a composable function that creates a fruit selector in the form of a dropdown menu. App : This is the main composable function that structures the application's user interface by combining different components.","title":"General Description"},{"location":"2.%20Android/09-etats-evenements-v2/#focus-on-fruitselector","text":"The FruitSelector function is a Jetpack Compose component that creates a dropdown menu allowing users to select a fruit from a predefined list. Here are its main features: Fruit List : A static list of fruits is defined at the beginning of the function. States : expanded : A boolean state that controls whether the dropdown menu is open or closed. selectedFruit : A state that stores the currently selected fruit. User Interface : Uses ExposedDropdownMenuBox to create the dropdown menu container. Displays a TextField that serves as a trigger to open the menu. This field is read-only and displays the selected fruit. The dropdown menu ( ExposedDropdownMenu ) contains the list of fruits, each represented by a DropdownMenuItem . Interaction : When a fruit is selected, the menu closes and the chosen fruit is displayed in the TextField. Additional text appears below to confirm the selected fruit. Layout : Uses a Column to vertically organize elements. Adds spacing and padding to improve appearance. Customization : Accepts a modifier parameter to allow additional customization if needed. This function demonstrates the use of several important Jetpack Compose concepts, such as state management, Material 3 UI components, and the creation of interactive components. It provides an intuitive user interface for selecting items from a list, which is a common functionality in many applications.","title":"Focus on FruitSelector"},{"location":"2.%20Android/09-etats-evenements-v2/#second-version","text":"@OptIn(ExperimentalMaterial3Api::class) @Composable fun FruitSelector( modifier: Modifier = Modifier, fruits: List<String>, selectedFruit: String, onFruitSelected: (String) -> Unit = {} ) { var expanded by remember { mutableStateOf(false) } Column(modifier = modifier.padding(16.dp)) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = { expanded = !expanded } ) { TextField( value = selectedFruit, onValueChange = {}, readOnly = true, label = { Text(\"Choose a fruit\") }, trailingIcon = { ExposedDropdownMenuDefaults .TrailingIcon(expanded = expanded) }, modifier = Modifier .menuAnchor() .fillMaxWidth() ) ExposedDropdownMenu( expanded = expanded, onDismissRequest = { expanded = false } ) { fruits.forEach { fruit -> DropdownMenuItem( text = { Text(fruit) }, onClick = { onFruitSelected(fruit) expanded = false } ) } } } Spacer(modifier = Modifier.height(16.dp)) if (selectedFruit.isNotEmpty()) { Text(\"Selected fruit: $selectedFruit\") } } } @Composable fun App(modifier: Modifier = Modifier) { var selectedFruit1 by rememberSaveable { mutableStateOf(\"\") } var selectedFruit2 by rememberSaveable { mutableStateOf(\"\") } Column(modifier = modifier) { TextLengthCounter() Spacer(modifier = Modifier.height(100.dp)) FruitSelector( fruits = listOf(\"Apple\", \"Banana\", \"Orange\", \"Strawberry\", \"Kiwi\"), selectedFruit = selectedFruit1, onFruitSelected = { fruit -> selectedFruit1 = fruit } ) Spacer(modifier = Modifier.height(10.dp)) FruitSelector( fruits = listOf(\"Pear\", \"Mango\", \"Orange\", \"Blueberry\", \"Grapefruit\"), selectedFruit = selectedFruit2, onFruitSelected = { fruit -> selectedFruit2 = fruit } ) Spacer(modifier = Modifier.height(10.dp)) Text(\"Selected fruit 1: ${selectedFruit1 ?: \"None\"}\") Text(\"Selected fruit 2: ${selectedFruit2 ?: \"None\"}\") } } This new version of the application demonstrates significant refactoring, primarily focused on state hoisting and component reusability. Let's examine the changes and their implications in detail:","title":"Second Version"},{"location":"2.%20Android/09-etats-evenements-v2/#fruitselector-refactoring","text":"State Hoisting : selectedFruit is no longer managed inside FruitSelector . It's now passed as a parameter. A new onFruitSelected function is added as a parameter to handle selection changes. Added Parameters : fruits: List<String> : The fruit list is now a parameter, making the component more flexible. selectedFruit: String : The selected fruit state is passed as a parameter. onFruitSelected: (String) -> Unit : A callback function to handle fruit selection. Remaining Local State : expanded remains a local state as it only concerns the dropdown menu display.","title":"FruitSelector Refactoring"},{"location":"2.%20Android/09-etats-evenements-v2/#changes-in-app","text":"State Management : Two new state variables are introduced: selectedFruit1 and selectedFruit2 . These states are created with rememberSaveable to persist across recompositions and configuration changes. FruitSelector Usage : Two instances of FruitSelector are created, each with its own fruit list and state. The state and update function are passed to each FruitSelector . Selection Display : Selected fruits are displayed at the bottom of the App, demonstrating that state is now managed at the top level.","title":"Changes in App"},{"location":"2.%20Android/09-etats-evenements-v2/#benefits-of-this-refactoring","text":"Reusability : FruitSelector can now be used multiple times with different fruit lists. Separation of Concerns : State management is separated from display, making the code more modular. Increased Control : The App now has full control over selection states, allowing for more complex interactions if needed. Improved Testability : It's easier to test FruitSelector as its behavior depends entirely on passed props. Flexibility : The fruit list can be dynamic, coming from an API or database, for example.","title":"Benefits of this Refactoring"},{"location":"2.%20Android/09-etats-evenements-v2/#focus-on-state-variables","text":"In App , selectedFruit1 and selectedFruit2 are state variables created with rememberSaveable . This means they will retain their value even during configuration changes (like screen rotation). In FruitSelector , only expanded remains a local state variable, as it only concerns the internal display of the component. This refactoring illustrates important Jetpack Compose principles, particularly state hoisting and creating reusable, independent components. It allows for better application state management and greater flexibility in building the user interface.","title":"Focus on State Variables"},{"location":"2.%20Android/10-localisation/","text":"10. Localization Here's a guide to integrate localization in an Android application developed with Jetpack Compose: General Principles of Localization Localizing an Android application involves adapting its content and user interface to different languages and cultures. Here are the key principles to follow: Externalize all strings in resource files. Use neutral identifiers for resources (e.g., \"welcome_message\" instead of \"english_welcome\"). Avoid hardcoding text in your code. Consider cultural differences (date formats, measurement units, etc.). Plan for extra space in your interface for longer translations. Test your application in different languages and configurations. Simple Example with Strings in English and French Step 1: Configure Language Resources 1- In the res folder, create a values-fr folder for French resources. 2- In res/values/strings.xml (default English): <resources> <string name=\"app_name\">My App</string> <string name=\"welcome_message\">Welcome to My App!</string> <string name=\"language_selection\">Select a language</string> </resources> 3- In res/values-fr/strings.xml : <resources> <string name=\"app_name\">Mon Application</string> <string name=\"welcome_message\">Bienvenue dans Mon Application !</string> <string name=\"language_selection\">S\u00e9lectionnez une langue</string> </resources> Step 2: Use Localized Strings in Jetpack Compose @Composable fun WelcomeScreen() { Column( modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = stringResource(R.string.welcome_message), style = MaterialTheme.typography.h4 ) Spacer(modifier = Modifier.height(16.dp)) Text( text = stringResource(R.string.language_selection), style = MaterialTheme.typography.body1 ) } } Date Formatting To format dates according to the user's locale, use the DateTimeFormatter class with ofLocalizedDate() : import java.time.LocalDate import java.time.format.DateTimeFormatter import java.time.format.FormatStyle @Composable fun DisplayLocalizedDate() { val currentDate = LocalDate.now() val dateFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG) val formattedDate = remember(currentDate) { currentDate.format(dateFormatter) } Text( text = formattedDate, style = MaterialTheme.typography.body1 ) } This code will display the current date in the appropriate long format for the user's locale. For example: In English (US): \"September 18, 2024\" In French: \"18 septembre 2024\" By following these steps, your Jetpack Compose application will be properly localized in English and French, with the ability to easily add other languages in the future. Citations: https://www.translized.com/blog/android-localization-with-jetpack-compose---a-comprehensive-guide https://phrase.com/blog/posts/localized-date-time-android/ https://www.youtube.com/watch?v=VdwDawvfH98 https://phrase.com/blog/posts/internationalizing-jetpack-compose-android-apps/ https://www.adamormsby.com/posts/013-android-localization-formatting-dates/ Complete Example Here's a complete example of a simple application using Jetpack Compose with localization, without buttons to change the language. This application will display a localized welcome message and the current date formatted according to the device's locale. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.* import androidx.compose.material.* import androidx.compose.runtime.* import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.res.stringResource import androidx.compose.ui.unit.dp import java.time.LocalDate import java.time.format.DateTimeFormatter import java.time.format.FormatStyle class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyApp() } } } @Composable fun MyApp() { MaterialTheme { Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background ) { LocalizedContent() } } } @Composable fun LocalizedContent() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = stringResource(R.string.welcome_message), style = MaterialTheme.typography.h4 ) Spacer(modifier = Modifier.height(16.dp)) DisplayLocalizedDate() } } @Composable fun DisplayLocalizedDate() { val currentDate = remember { LocalDate.now() } val dateFormatter = remember { DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG) } val formattedDate = remember(currentDate) { currentDate.format(dateFormatter) } Text( text = formattedDate, style = MaterialTheme.typography.body1 ) } For this application to work correctly, you also need to configure the following resource files: In res/values/strings.xml (default English): <resources> <string name=\"app_name\">My Localized App</string> <string name=\"welcome_message\">Welcome to My Localized App!</string> </resources> In res/values-fr/strings.xml (for French): <resources> <string name=\"app_name\">Mon Application Localis\u00e9e</string> <string name=\"welcome_message\">Bienvenue dans Mon Application Localis\u00e9e !</string> </resources> Make sure you have the necessary dependencies in your build.gradle (Module: app) file: dependencies { implementation \"androidx.compose.ui:ui:1.5.0\" implementation \"androidx.compose.material:material:1.5.0\" implementation \"androidx.compose.ui:ui-tooling-preview:1.5.0\" implementation \"androidx.activity:activity-compose:1.7.2\" } This simple application displays: A localized welcome message The current date formatted according to the device's locale The application will automatically use the appropriate resources based on the language configured on the user's device. If the device is set to French, it will use the strings from the values-fr/strings.xml file. For any other language, it will use the default strings from the values/strings.xml file. To test different languages, you can change the language of your device or emulator in the system settings. The application will automatically adapt to the new language without requiring a restart.","title":"10. Localization"},{"location":"2.%20Android/10-localisation/#10-localization","text":"Here's a guide to integrate localization in an Android application developed with Jetpack Compose:","title":"10. Localization"},{"location":"2.%20Android/10-localisation/#general-principles-of-localization","text":"Localizing an Android application involves adapting its content and user interface to different languages and cultures. Here are the key principles to follow: Externalize all strings in resource files. Use neutral identifiers for resources (e.g., \"welcome_message\" instead of \"english_welcome\"). Avoid hardcoding text in your code. Consider cultural differences (date formats, measurement units, etc.). Plan for extra space in your interface for longer translations. Test your application in different languages and configurations.","title":"General Principles of Localization"},{"location":"2.%20Android/10-localisation/#simple-example-with-strings-in-english-and-french","text":"","title":"Simple Example with Strings in English and French"},{"location":"2.%20Android/10-localisation/#step-1-configure-language-resources","text":"1- In the res folder, create a values-fr folder for French resources. 2- In res/values/strings.xml (default English): <resources> <string name=\"app_name\">My App</string> <string name=\"welcome_message\">Welcome to My App!</string> <string name=\"language_selection\">Select a language</string> </resources> 3- In res/values-fr/strings.xml : <resources> <string name=\"app_name\">Mon Application</string> <string name=\"welcome_message\">Bienvenue dans Mon Application !</string> <string name=\"language_selection\">S\u00e9lectionnez une langue</string> </resources>","title":"Step 1: Configure Language Resources"},{"location":"2.%20Android/10-localisation/#step-2-use-localized-strings-in-jetpack-compose","text":"@Composable fun WelcomeScreen() { Column( modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = stringResource(R.string.welcome_message), style = MaterialTheme.typography.h4 ) Spacer(modifier = Modifier.height(16.dp)) Text( text = stringResource(R.string.language_selection), style = MaterialTheme.typography.body1 ) } }","title":"Step 2: Use Localized Strings in Jetpack Compose"},{"location":"2.%20Android/10-localisation/#date-formatting","text":"To format dates according to the user's locale, use the DateTimeFormatter class with ofLocalizedDate() : import java.time.LocalDate import java.time.format.DateTimeFormatter import java.time.format.FormatStyle @Composable fun DisplayLocalizedDate() { val currentDate = LocalDate.now() val dateFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG) val formattedDate = remember(currentDate) { currentDate.format(dateFormatter) } Text( text = formattedDate, style = MaterialTheme.typography.body1 ) } This code will display the current date in the appropriate long format for the user's locale. For example: In English (US): \"September 18, 2024\" In French: \"18 septembre 2024\" By following these steps, your Jetpack Compose application will be properly localized in English and French, with the ability to easily add other languages in the future. Citations: https://www.translized.com/blog/android-localization-with-jetpack-compose---a-comprehensive-guide https://phrase.com/blog/posts/localized-date-time-android/ https://www.youtube.com/watch?v=VdwDawvfH98 https://phrase.com/blog/posts/internationalizing-jetpack-compose-android-apps/ https://www.adamormsby.com/posts/013-android-localization-formatting-dates/","title":"Date Formatting"},{"location":"2.%20Android/10-localisation/#complete-example","text":"Here's a complete example of a simple application using Jetpack Compose with localization, without buttons to change the language. This application will display a localized welcome message and the current date formatted according to the device's locale. import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.foundation.layout.* import androidx.compose.material.* import androidx.compose.runtime.* import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.res.stringResource import androidx.compose.ui.unit.dp import java.time.LocalDate import java.time.format.DateTimeFormatter import java.time.format.FormatStyle class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyApp() } } } @Composable fun MyApp() { MaterialTheme { Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background ) { LocalizedContent() } } } @Composable fun LocalizedContent() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally ) { Text( text = stringResource(R.string.welcome_message), style = MaterialTheme.typography.h4 ) Spacer(modifier = Modifier.height(16.dp)) DisplayLocalizedDate() } } @Composable fun DisplayLocalizedDate() { val currentDate = remember { LocalDate.now() } val dateFormatter = remember { DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG) } val formattedDate = remember(currentDate) { currentDate.format(dateFormatter) } Text( text = formattedDate, style = MaterialTheme.typography.body1 ) } For this application to work correctly, you also need to configure the following resource files: In res/values/strings.xml (default English): <resources> <string name=\"app_name\">My Localized App</string> <string name=\"welcome_message\">Welcome to My Localized App!</string> </resources> In res/values-fr/strings.xml (for French): <resources> <string name=\"app_name\">Mon Application Localis\u00e9e</string> <string name=\"welcome_message\">Bienvenue dans Mon Application Localis\u00e9e !</string> </resources> Make sure you have the necessary dependencies in your build.gradle (Module: app) file: dependencies { implementation \"androidx.compose.ui:ui:1.5.0\" implementation \"androidx.compose.material:material:1.5.0\" implementation \"androidx.compose.ui:ui-tooling-preview:1.5.0\" implementation \"androidx.activity:activity-compose:1.7.2\" } This simple application displays: A localized welcome message The current date formatted according to the device's locale The application will automatically use the appropriate resources based on the language configured on the user's device. If the device is set to French, it will use the strings from the values-fr/strings.xml file. For any other language, it will use the default strings from the values/strings.xml file. To test different languages, you can change the language of your device or emulator in the system settings. The application will automatically adapt to the new language without requiring a restart.","title":"Complete Example"},{"location":"2.%20Android/11-json/","text":"11. Reading and Writing JSON Files Saving and Reading JSON Data in Kotlin Step 1: Preparation For example, the Player class is defined as follows: data class Player( val id: Int, val number: Int, val name: String, val image_resource: Int = R.drawable.nhl_logo ) We'll use the Gson library for JSON serialization and deserialization. Add the following dependency in the module's build.gradle file directly in the dependencies section of the app/build.gradle.kts file: implementation(\"com.google.code.gson:gson:2.10.1\") Another option offered by Android Studio is to convert this dependency to the Version Catalogs format. You can accept this format change. The line above will be replaced by: implementation(libs.gson) And two lines will be added to gradle/libs.versions.toml for gson : [versions] gson = \"2.10.1\" [libraries] gson = { module = \"com.google.code.gson:gson\", version.ref = \"gson\" } Step 2: Saving Data to a JSON File To save a list of Player to a JSON file, we'll create an extension function: import com.google.gson.Gson import java.io.File fun List<Player>.saveToFile(filename: String) { val jsonString = Gson().toJson(this) File(filename).writeText(jsonString) } This function converts the list of Player to a JSON string, then writes it to a file. Step 3: Reading Data from a JSON File To read the list of Player from a JSON file, we'll create another function: import com.google.gson.Gson import com.google.gson.reflect.TypeToken import java.io.File fun readPlayersFromFile(filename: String): List<Player> { val jsonString = File(filename).readText() val playerListType = object : TypeToken<List<Player>>() {}.type return Gson().fromJson(jsonString, playerListType) } This function reads the content of the JSON file, then converts it to a list of Player . Step 4: Using the Functions Here's an example of using these functions: fun main() { // Creating a list of players val players = listOf( Player(1, 99, \"Wayne Gretzky\"), Player(2, 87, \"Sidney Crosby\"), Player(3, 9, \"Bobby Orr\") ) // Saving players to a JSON file players.saveToFile(\"players.json\") println(\"Players saved to players.json\") // Reading players from the JSON file val loadedPlayers = readPlayersFromFile(\"players.json\") println(\"Players loaded from players.json:\") loadedPlayers.forEach { println(it) } } Important Points Serialization : This is the process of converting objects to JSON format. Deserialization : This is the reverse process, converting JSON to Kotlin objects. File Management : Kotlin offers simple methods for reading and writing files. Gson Library : It greatly simplifies working with JSON in Kotlin. Data Class : Using data class for Player facilitates serialization/deserialization. File Management in Android Overwriting and Creating Files Overwriting Existing File When using the File(filename).writeText(jsonString) method, if the specified file already exists, its content will be effectively overwritten. This operation completely replaces the previous content with new data. Creating a New File If the specified file doesn't exist, Android will automatically create it before writing the data. This means you don't need to check for the file's existence or create it manually. File Location The file location depends on the path you specify in the filename parameter. In the context of an Android application, it's crucial to understand the different storage options: Internal Storage By default, if you use a relative path, the file will be created in your application's private directory. Typical path: /data/data/[your_app_package_name]/files/ This directory is private and accessible only by your application. External Storage To write to external storage (like SD card), you must request appropriate permissions and use an absolute path ( see another section). Example: Environment.getExternalStorageDirectory().absolutePath + \"/MyFolder/myfile.json\" Best Practices for Android Applications Using Application Context For better file management in an Android application, it's recommended to use the application context to get the appropriate directory: fun Context.saveToFile(players: List<Player>, filename: String) { val file = File(this.filesDir, filename) file.writeText(Gson().toJson(players)) } fun Context.readPlayersFromFile(filename: String): List<Player> { val file = File(this.filesDir, filename) val jsonString = file.readText() val playerListType = object : TypeToken<List<Player>>() {}.type return Gson().fromJson(jsonString, playerListType) } Error Handling It's important to add error handling to handle cases where writing or reading might fail: fun Context.saveToFile(players: List<Player>, filename: String) { try { val file = File(this.filesDir, filename) file.writeText(Gson().toJson(players)) } catch (e: Exception) { Log.e(\"FileIO\", \"Error writing file\", e) } } Checking File Existence Before reading a file, it's wise to check its existence: fun Context.readPlayersFromFile(filename: String): List<Player>? { val file = File(this.filesDir, filename) return if (file.exists()) { try { val jsonString = file.readText() val playerListType = object : TypeToken<List<Player>>() {}.type Gson().fromJson(jsonString, playerListType) } catch (e: Exception) { Log.e(\"FileIO\", \"Error reading file\", e) emptyList() } } else { emptyList() } }","title":"11. Reading and Writing JSON Files"},{"location":"2.%20Android/11-json/#11-reading-and-writing-json-files","text":"","title":"11. Reading and Writing JSON Files"},{"location":"2.%20Android/11-json/#saving-and-reading-json-data-in-kotlin","text":"","title":"Saving and Reading JSON Data in Kotlin"},{"location":"2.%20Android/11-json/#step-1-preparation","text":"For example, the Player class is defined as follows: data class Player( val id: Int, val number: Int, val name: String, val image_resource: Int = R.drawable.nhl_logo ) We'll use the Gson library for JSON serialization and deserialization. Add the following dependency in the module's build.gradle file directly in the dependencies section of the app/build.gradle.kts file: implementation(\"com.google.code.gson:gson:2.10.1\") Another option offered by Android Studio is to convert this dependency to the Version Catalogs format. You can accept this format change. The line above will be replaced by: implementation(libs.gson) And two lines will be added to gradle/libs.versions.toml for gson : [versions] gson = \"2.10.1\" [libraries] gson = { module = \"com.google.code.gson:gson\", version.ref = \"gson\" }","title":"Step 1: Preparation"},{"location":"2.%20Android/11-json/#step-2-saving-data-to-a-json-file","text":"To save a list of Player to a JSON file, we'll create an extension function: import com.google.gson.Gson import java.io.File fun List<Player>.saveToFile(filename: String) { val jsonString = Gson().toJson(this) File(filename).writeText(jsonString) } This function converts the list of Player to a JSON string, then writes it to a file.","title":"Step 2: Saving Data to a JSON File"},{"location":"2.%20Android/11-json/#step-3-reading-data-from-a-json-file","text":"To read the list of Player from a JSON file, we'll create another function: import com.google.gson.Gson import com.google.gson.reflect.TypeToken import java.io.File fun readPlayersFromFile(filename: String): List<Player> { val jsonString = File(filename).readText() val playerListType = object : TypeToken<List<Player>>() {}.type return Gson().fromJson(jsonString, playerListType) } This function reads the content of the JSON file, then converts it to a list of Player .","title":"Step 3: Reading Data from a JSON File"},{"location":"2.%20Android/11-json/#step-4-using-the-functions","text":"Here's an example of using these functions: fun main() { // Creating a list of players val players = listOf( Player(1, 99, \"Wayne Gretzky\"), Player(2, 87, \"Sidney Crosby\"), Player(3, 9, \"Bobby Orr\") ) // Saving players to a JSON file players.saveToFile(\"players.json\") println(\"Players saved to players.json\") // Reading players from the JSON file val loadedPlayers = readPlayersFromFile(\"players.json\") println(\"Players loaded from players.json:\") loadedPlayers.forEach { println(it) } }","title":"Step 4: Using the Functions"},{"location":"2.%20Android/11-json/#important-points","text":"Serialization : This is the process of converting objects to JSON format. Deserialization : This is the reverse process, converting JSON to Kotlin objects. File Management : Kotlin offers simple methods for reading and writing files. Gson Library : It greatly simplifies working with JSON in Kotlin. Data Class : Using data class for Player facilitates serialization/deserialization.","title":"Important Points"},{"location":"2.%20Android/11-json/#file-management-in-android","text":"","title":"File Management in Android"},{"location":"2.%20Android/11-json/#overwriting-and-creating-files","text":"Overwriting Existing File When using the File(filename).writeText(jsonString) method, if the specified file already exists, its content will be effectively overwritten. This operation completely replaces the previous content with new data. Creating a New File If the specified file doesn't exist, Android will automatically create it before writing the data. This means you don't need to check for the file's existence or create it manually.","title":"Overwriting and Creating Files"},{"location":"2.%20Android/11-json/#file-location","text":"The file location depends on the path you specify in the filename parameter. In the context of an Android application, it's crucial to understand the different storage options: Internal Storage By default, if you use a relative path, the file will be created in your application's private directory. Typical path: /data/data/[your_app_package_name]/files/ This directory is private and accessible only by your application. External Storage To write to external storage (like SD card), you must request appropriate permissions and use an absolute path ( see another section). Example: Environment.getExternalStorageDirectory().absolutePath + \"/MyFolder/myfile.json\"","title":"File Location"},{"location":"2.%20Android/11-json/#best-practices-for-android-applications","text":"","title":"Best Practices for Android Applications"},{"location":"2.%20Android/11-json/#using-application-context","text":"For better file management in an Android application, it's recommended to use the application context to get the appropriate directory: fun Context.saveToFile(players: List<Player>, filename: String) { val file = File(this.filesDir, filename) file.writeText(Gson().toJson(players)) } fun Context.readPlayersFromFile(filename: String): List<Player> { val file = File(this.filesDir, filename) val jsonString = file.readText() val playerListType = object : TypeToken<List<Player>>() {}.type return Gson().fromJson(jsonString, playerListType) }","title":"Using Application Context"},{"location":"2.%20Android/11-json/#error-handling","text":"It's important to add error handling to handle cases where writing or reading might fail: fun Context.saveToFile(players: List<Player>, filename: String) { try { val file = File(this.filesDir, filename) file.writeText(Gson().toJson(players)) } catch (e: Exception) { Log.e(\"FileIO\", \"Error writing file\", e) } }","title":"Error Handling"},{"location":"2.%20Android/11-json/#checking-file-existence","text":"Before reading a file, it's wise to check its existence: fun Context.readPlayersFromFile(filename: String): List<Player>? { val file = File(this.filesDir, filename) return if (file.exists()) { try { val jsonString = file.readText() val playerListType = object : TypeToken<List<Player>>() {}.type Gson().fromJson(jsonString, playerListType) } catch (e: Exception) { Log.e(\"FileIO\", \"Error reading file\", e) emptyList() } } else { emptyList() } }","title":"Checking File Existence"},{"location":"2.%20Android/12-cycle-de-vie/","text":"12. Lifecycle and Architecture General Android Application Lifecycle Fundamental Concepts An Android application consists of different components, each with its own lifecycle, but the main element is the * Activity *. An activity represents a screen of the application with which the user can interact. The lifecycle of an activity extends from its creation to its destruction, when the system reclaims its resources. Understanding this lifecycle is essential for: Avoiding crashes during interruptions (phone calls, app switching) Optimizing system resource usage Preserving application data and state Properly handling configuration changes (screen rotation) Main Activity States An activity can be in four main states: Active/Resumed : The activity is in the foreground and interactive Paused : Visible but has lost focus Stopped : Not visible but kept in memory Destroyed : The activity is terminated Lifecycle Lifecycle Methods The main methods called during state transitions are: onCreate() : Activity initialization onStart() : Activity becomes visible onResume() : Activity becomes interactive onPause() : Activity loses focus onStop() : Activity is no longer visible onDestroy() : Activity is destroyed Jetpack Compose Specificities Declarative Approach Jetpack Compose uses a different approach from the traditional lifecycle. Instead of directly managing state changes through callback methods, Compose uses a declarative paradigm. State Management In Compose, the lifecycle is closely tied to state management: Composables are either stateless or stateful State is managed through State<T> objects and the remember{} function Recomposition occurs automatically when state changes Effects and Lifecycle Compose introduces specific effects to manage lifecycle-related operations: @Composable fun MyComposable() { // Effect executed at each recomposition LaunchedEffect(key1) { // Code to execute } // Effect executed only at first composition DisposableEffect(key1) { onDispose { // Resource cleanup } } } Best Practices For an efficient Compose application: Favor stateless components Hoist state to the appropriate level Use effects for operations with side effects Avoid side effects in composables Properly manage recomposition to optimize performance By understanding these concepts, you can develop robust Android applications that properly handle their lifecycle, whether using the traditional approach or Jetpack Compose. Citations: https://developer.android.com/codelabs/basic-android-kotlin-compose-activity-lifecycle?hl=fr https://appmaster.io/fr/blog/jetpack-compose-un-guide-du-debutant https://www.weblineindia.com/fr/blog/android-app-development-lifecycle.html https://appmaster.io/fr/blog/kotlin-avec-jetpack-compose-les-meilleures-pratiques http://www.iro.umontreal.ca/~dift1155/cours/ift1155/communs/Cours/2P/C02_CycledeVie_2P.pdf https://developer.android.com/jetpack/androidx/releases/lifecycle?hl=fr https://developer.android.com/codelabs/basic-android-kotlin-training-activity-lifecycle?hl=fr https://developer.android.com/develop/ui/compose/state?hl=fr https://www.yeeply.com/fr/blog/developpement-applications-mobiles/cycle-de-vie-developpement-logiciels-mobiles/ https://developer.android.com/guide/components/activities/activity-lifecycle?hl=fr https://openclassrooms.com/fr/courses/8150246-developpez-votre-premiere-application-android/8256687-apprehendez-le-cycle-de-vie-d-une-application https://www.editions-eni.fr/livre/jetpack-compose-developpez-des-interfaces-accessibles-et-modernes-pour-android-9782409039669/gestion-des-etats-et-des-effets https://www.lirmm.fr/~fmichel/ens/android/cours/Android_lifecycle.pdf https://mathias-seguy.developpez.com/tutoriels/android/comprendre-cyclevie-activite/","title":"12. Lifecycle and Architecture"},{"location":"2.%20Android/12-cycle-de-vie/#12-lifecycle-and-architecture","text":"","title":"12. Lifecycle and Architecture"},{"location":"2.%20Android/12-cycle-de-vie/#general-android-application-lifecycle","text":"","title":"General Android Application Lifecycle"},{"location":"2.%20Android/12-cycle-de-vie/#fundamental-concepts","text":"An Android application consists of different components, each with its own lifecycle, but the main element is the * Activity *. An activity represents a screen of the application with which the user can interact. The lifecycle of an activity extends from its creation to its destruction, when the system reclaims its resources. Understanding this lifecycle is essential for: Avoiding crashes during interruptions (phone calls, app switching) Optimizing system resource usage Preserving application data and state Properly handling configuration changes (screen rotation)","title":"Fundamental Concepts"},{"location":"2.%20Android/12-cycle-de-vie/#main-activity-states","text":"An activity can be in four main states: Active/Resumed : The activity is in the foreground and interactive Paused : Visible but has lost focus Stopped : Not visible but kept in memory Destroyed : The activity is terminated Lifecycle","title":"Main Activity States"},{"location":"2.%20Android/12-cycle-de-vie/#lifecycle-methods","text":"The main methods called during state transitions are: onCreate() : Activity initialization onStart() : Activity becomes visible onResume() : Activity becomes interactive onPause() : Activity loses focus onStop() : Activity is no longer visible onDestroy() : Activity is destroyed","title":"Lifecycle Methods"},{"location":"2.%20Android/12-cycle-de-vie/#jetpack-compose-specificities","text":"","title":"Jetpack Compose Specificities"},{"location":"2.%20Android/12-cycle-de-vie/#declarative-approach","text":"Jetpack Compose uses a different approach from the traditional lifecycle. Instead of directly managing state changes through callback methods, Compose uses a declarative paradigm.","title":"Declarative Approach"},{"location":"2.%20Android/12-cycle-de-vie/#state-management","text":"In Compose, the lifecycle is closely tied to state management: Composables are either stateless or stateful State is managed through State<T> objects and the remember{} function Recomposition occurs automatically when state changes","title":"State Management"},{"location":"2.%20Android/12-cycle-de-vie/#effects-and-lifecycle","text":"Compose introduces specific effects to manage lifecycle-related operations: @Composable fun MyComposable() { // Effect executed at each recomposition LaunchedEffect(key1) { // Code to execute } // Effect executed only at first composition DisposableEffect(key1) { onDispose { // Resource cleanup } } }","title":"Effects and Lifecycle"},{"location":"2.%20Android/12-cycle-de-vie/#best-practices","text":"For an efficient Compose application: Favor stateless components Hoist state to the appropriate level Use effects for operations with side effects Avoid side effects in composables Properly manage recomposition to optimize performance By understanding these concepts, you can develop robust Android applications that properly handle their lifecycle, whether using the traditional approach or Jetpack Compose. Citations: https://developer.android.com/codelabs/basic-android-kotlin-compose-activity-lifecycle?hl=fr https://appmaster.io/fr/blog/jetpack-compose-un-guide-du-debutant https://www.weblineindia.com/fr/blog/android-app-development-lifecycle.html https://appmaster.io/fr/blog/kotlin-avec-jetpack-compose-les-meilleures-pratiques http://www.iro.umontreal.ca/~dift1155/cours/ift1155/communs/Cours/2P/C02_CycledeVie_2P.pdf https://developer.android.com/jetpack/androidx/releases/lifecycle?hl=fr https://developer.android.com/codelabs/basic-android-kotlin-training-activity-lifecycle?hl=fr https://developer.android.com/develop/ui/compose/state?hl=fr https://www.yeeply.com/fr/blog/developpement-applications-mobiles/cycle-de-vie-developpement-logiciels-mobiles/ https://developer.android.com/guide/components/activities/activity-lifecycle?hl=fr https://openclassrooms.com/fr/courses/8150246-developpez-votre-premiere-application-android/8256687-apprehendez-le-cycle-de-vie-d-une-application https://www.editions-eni.fr/livre/jetpack-compose-developpez-des-interfaces-accessibles-et-modernes-pour-android-9782409039669/gestion-des-etats-et-des-effets https://www.lirmm.fr/~fmichel/ens/android/cours/Android_lifecycle.pdf https://mathias-seguy.developpez.com/tutoriels/android/comprendre-cyclevie-activite/","title":"Best Practices"},{"location":"2.%20Android/13-architecture/","text":"13. Architecture Layered Architecture A modern Android application with Jetpack Compose should follow a distinct layered architecture: UI Layer (Presentation) The UI layer is responsible for displaying data and handling user interactions. With Jetpack Compose, it includes: Main Components: UI Composables ViewModels UI State UI Events @Composable fun MyScreen( viewModel: MyViewModel = viewModel() ) { val uiState by viewModel.uiState.collectAsState() Column { // UI elements } } Domain Layer (Optional) This intermediate layer contains the business logic and bridges UI and Data: Use cases Domain models Business logic class GetUserUseCase( private val userRepository: UserRepository ) { suspend operator fun invoke(userId: String): User { return userRepository.getUser(userId) } } Data Layer Manages application data: Repositories Data sources (API, database) Data models class UserRepository( private val api: ApiService, private val database: AppDatabase ) { suspend fun getUser(id: String): User { return database.userDao().getUser(id) ?: api.fetchUser(id).also { user -> database.userDao().insert(user) } } } State Management with Compose UI State UI state is managed through: State hoisting ViewModel with StateFlow / SharedFlow remember / rememberSaveable class MyViewModel : ViewModel() { private val _uiState = MutableStateFlow(MyUiState()) val uiState: StateFlow<MyUiState> = _uiState.asStateFlow() fun handleEvent(event: MyUiEvent) { // Update state based on events } } Side Effects Effects are managed with Compose APIs: @Composable fun MyScreen() { LaunchedEffect(key1) { // One-time setup } DisposableEffect(key1) { onDispose { // Cleanup } } } Navigation Navigation is handled by Navigation Compose: @Composable fun AppNavigation() { val navController = rememberNavController() NavHost(navController, startDestination = \"home\") { composable(\"home\") { HomeScreen() } composable(\"details/{id}\") { backStackEntry -> DetailsScreen(backStackEntry.arguments?.getString(\"id\")) } } } Dependency Injection Hilt is recommended for dependency injection: @HiltViewModel class MainViewModel @Inject constructor( private val userRepository: UserRepository ) : ViewModel() Best Practices Unidirectional Data Flow (UDF) UI events flow up to the ViewModel State flows down to UI composables State Hoisting Separate state from its manipulation Lift state to appropriate level Single Source of Truth One source of truth for data Use Flow for reactivity Stateless Composables Prefer stateless composables when possible Separate logic from display Modularization Divide application into functional modules Use feature modules for better scalability This architecture enables creating maintainable, testable, and scalable applications with Jetpack Compose. Citations: https://www.geeksforgeeks.org/android-architecture/ https://www.simform.com/blog/mobile-application-architecture/ https://www.intelivita.com/blog/android-architecture-patterns/ https://developer.android.com/topic/architecture?hl=en https://w3r.one/fr/blog/mobile/android/architecture-android/comprendre-architecture-android-vie-ensemble-composants-modeles https://www.zucisystems.com/be/blog/limportance-de-larchitecture-mobile-concevoir-des-applications-pour-reussir/ https://appmaster.io/fr/blog/kotlin-avec-jetpack-compose-les-meilleures-pratiques https://developer.android.com/jetpack/androidx/releases/lifecycle?hl=fr","title":"13. Architecture"},{"location":"2.%20Android/13-architecture/#13-architecture","text":"","title":"13. Architecture"},{"location":"2.%20Android/13-architecture/#layered-architecture","text":"A modern Android application with Jetpack Compose should follow a distinct layered architecture:","title":"Layered Architecture"},{"location":"2.%20Android/13-architecture/#ui-layer-presentation","text":"The UI layer is responsible for displaying data and handling user interactions. With Jetpack Compose, it includes: Main Components: UI Composables ViewModels UI State UI Events @Composable fun MyScreen( viewModel: MyViewModel = viewModel() ) { val uiState by viewModel.uiState.collectAsState() Column { // UI elements } }","title":"UI Layer (Presentation)"},{"location":"2.%20Android/13-architecture/#domain-layer-optional","text":"This intermediate layer contains the business logic and bridges UI and Data: Use cases Domain models Business logic class GetUserUseCase( private val userRepository: UserRepository ) { suspend operator fun invoke(userId: String): User { return userRepository.getUser(userId) } }","title":"Domain Layer (Optional)"},{"location":"2.%20Android/13-architecture/#data-layer","text":"Manages application data: Repositories Data sources (API, database) Data models class UserRepository( private val api: ApiService, private val database: AppDatabase ) { suspend fun getUser(id: String): User { return database.userDao().getUser(id) ?: api.fetchUser(id).also { user -> database.userDao().insert(user) } } }","title":"Data Layer"},{"location":"2.%20Android/13-architecture/#state-management-with-compose","text":"","title":"State Management with Compose"},{"location":"2.%20Android/13-architecture/#ui-state","text":"UI state is managed through: State hoisting ViewModel with StateFlow / SharedFlow remember / rememberSaveable class MyViewModel : ViewModel() { private val _uiState = MutableStateFlow(MyUiState()) val uiState: StateFlow<MyUiState> = _uiState.asStateFlow() fun handleEvent(event: MyUiEvent) { // Update state based on events } }","title":"UI State"},{"location":"2.%20Android/13-architecture/#side-effects","text":"Effects are managed with Compose APIs: @Composable fun MyScreen() { LaunchedEffect(key1) { // One-time setup } DisposableEffect(key1) { onDispose { // Cleanup } } }","title":"Side Effects"},{"location":"2.%20Android/13-architecture/#navigation","text":"Navigation is handled by Navigation Compose: @Composable fun AppNavigation() { val navController = rememberNavController() NavHost(navController, startDestination = \"home\") { composable(\"home\") { HomeScreen() } composable(\"details/{id}\") { backStackEntry -> DetailsScreen(backStackEntry.arguments?.getString(\"id\")) } } }","title":"Navigation"},{"location":"2.%20Android/13-architecture/#dependency-injection","text":"Hilt is recommended for dependency injection: @HiltViewModel class MainViewModel @Inject constructor( private val userRepository: UserRepository ) : ViewModel()","title":"Dependency Injection"},{"location":"2.%20Android/13-architecture/#best-practices","text":"Unidirectional Data Flow (UDF) UI events flow up to the ViewModel State flows down to UI composables State Hoisting Separate state from its manipulation Lift state to appropriate level Single Source of Truth One source of truth for data Use Flow for reactivity Stateless Composables Prefer stateless composables when possible Separate logic from display Modularization Divide application into functional modules Use feature modules for better scalability This architecture enables creating maintainable, testable, and scalable applications with Jetpack Compose. Citations: https://www.geeksforgeeks.org/android-architecture/ https://www.simform.com/blog/mobile-application-architecture/ https://www.intelivita.com/blog/android-architecture-patterns/ https://developer.android.com/topic/architecture?hl=en https://w3r.one/fr/blog/mobile/android/architecture-android/comprendre-architecture-android-vie-ensemble-composants-modeles https://www.zucisystems.com/be/blog/limportance-de-larchitecture-mobile-concevoir-des-applications-pour-reussir/ https://appmaster.io/fr/blog/kotlin-avec-jetpack-compose-les-meilleures-pratiques https://developer.android.com/jetpack/androidx/releases/lifecycle?hl=fr","title":"Best Practices"},{"location":"2.%20Android/14-navigation/","text":"14. Navigation in Jetpack Compose Git Repository Example with Buttons to Navigate Between Composables Initial Setup First, add the dependency in the build.gradle file: dependencies { implementation(\"androidx.navigation:navigation-compose:2.8.3\") } Example Structure We will create an application with three screens: Home screen Profile screen Settings screen Route Definition sealed class Screen(val route: String) { object Home : Screen(\"home\") object Profile : Screen(\"profile\") object Settings : Screen(\"settings\") } Screen Composable Creation @Composable fun HomeScreen(navController: NavController) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Home Screen\") Button(onClick = { navController.navigate(Screen.Profile.route) }) { Text(\"Go to Profile\") } Button(onClick = { navController.navigate(Screen.Settings.route) }) { Text(\"Go to Settings\") } } } @Composable fun ProfileScreen(navController: NavController) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Profile Screen\") Button(onClick = { navController.navigate(Screen.Settings.route) }) { Text(\"Go to Settings\") } Button(onClick = { navController.popBackStack() }) { Text(\"Back\") } } } @Composable fun SettingsScreen(navController: NavController) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Settings Screen\") Button(onClick = { navController.popBackStack() }) { Text(\"Back\") } Button( onClick = { navController.navigate(Screen.Home.route) { popUpTo(Screen.Home.route) { inclusive = true } } } ) { Text(\"Back to Home\") } } } Navigation Configuration @Composable fun AppNavigation() { val navController = rememberNavController() NavHost( navController = navController, startDestination = Screen.Home.route ) { composable(Screen.Home.route) { HomeScreen(navController) } composable(Screen.Profile.route) { ProfileScreen(navController) } composable(Screen.Settings.route) { SettingsScreen(navController) } } } Integration in MainActivity class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyTheme { Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background ) { AppNavigation() } } } } } Demonstrated Features Basic Navigation : Navigation between screens using navigate() Back Navigation : Using popBackStack() Navigation with Stack Clearing : Using popUpTo to return to home Important Points The NavController manages the navigation state The NavHost defines the navigation graph Each screen receives the NavController to manage navigation popBackStack() allows returning to the previous screen popUpTo with inclusive = true allows going back to a destination while including it in the removal This example shows the basics of navigation in Jetpack Compose while remaining simple and understandable for beginners. Citations: [1] https://proandroiddev.com/android-jetpack-compose-navigation-1cdfc488b891?gi=d31e0323b815 https://saurabhjadhavblogs.com/ultimate-guide-to-jetpack-compose-navigation https://blog.kotlin-academy.com/mastery-navigation-in-jetpack-compose-db00b0a0ef75?gi=007e50484ede https://developer.android.com/develop/ui/compose/navigation https://proandroiddev.com/mastering-navigation-in-jetpack-compose-a-guide-to-using-the-inclusive-attribute-b66916a5f15c?gi=401071494588 https://developer.android.com/codelabs/basic-android-kotlin-compose-navigation https://developer.android.com/develop/ui/compose/navigation?hl=fr https://www.youtube.com/watch?v=AIC_OFQ1r3k Example with Menu in Application Top Bar Application Structure sealed class Screen(val route: String, val title: String) { object Home : Screen(\"home\", \"Home\") object Profile : Screen(\"profile\", \"Profile\") object Settings : Screen(\"settings\", \"Settings\") } Navigation Configuration @Composable fun AppNavigation() { val navController = rememberNavController() Scaffold( topBar = { TopAppBarWithMenu(navController) } ) { paddingValues -> NavHost( navController = navController, startDestination = Screen.Home.route, modifier = Modifier.padding(paddingValues) ) { composable(Screen.Home.route) { HomeScreen() } composable(Screen.Profile.route) { ProfileScreen() } composable(Screen.Settings.route) { SettingsScreen() } } } } TopBar with Menu @Composable fun TopAppBarWithMenu(navController: NavController) { var showMenu by remember { mutableStateOf(false) } TopAppBar( title = { Text(\"My Application\") }, actions = { IconButton(onClick = { showMenu = !showMenu }) { Icon(Icons.Default.MoreVert, contentDescription = \"Menu\") } DropdownMenu( expanded = showMenu, onDismissRequest = { showMenu = false } ) { DropdownMenuItem( text = { Text(Screen.Home.title) }, onClick = { navController.navigate(Screen.Home.route) { popUpTo(Screen.Home.route) { inclusive = true } } showMenu = false } ) DropdownMenuItem( text = { Text(Screen.Profile.title) }, onClick = { navController.navigate(Screen.Profile.route) showMenu = false } ) DropdownMenuItem( text = { Text(Screen.Settings.title) }, onClick = { navController.navigate(Screen.Settings.route) showMenu = false } ) } } ) } Application Screens @Composable fun HomeScreen() { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Home Screen\") } } @Composable fun ProfileScreen() { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Profile Screen\") } } @Composable fun SettingsScreen() { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Settings Screen\") } } Important Points to Note The menu is managed by a showMenu state that controls the DropdownMenu display Each menu item uses navController.navigate() for navigation For the home screen, we use popUpTo with inclusive = true to avoid accumulating screens in the navigation stack The Scaffold automatically manages the necessary padding to prevent content from being hidden behind the TopBar The screens are simple but can be enriched according to the application's needs This implementation offers clear and intuitive navigation via a dropdown menu in the application's top bar. Citations: https://saurabhjadhavblogs.com/ultimate-guide-to-jetpack-compose-navigation https://proandroiddev.com/android-jetpack-compose-navigation-1cdfc488b891?gi=d31e0323b815 https://proandroiddev.com/implement-bottom-bar-navigation-in-jetpack-compose-b530b1cd9ee2?gi=5c1ab6e9d027 https://proandroiddev.com/mastering-navigation-in-jetpack-compose-a-guide-to-using-the-inclusive-attribute-b66916a5f15c?gi=401071494588 https://blog.kotlin-academy.com/mastery-navigation-in-jetpack-compose-db00b0a0ef75?gi=007e50484ede https://developer.android.com/codelabs/basic-android-kotlin-compose-navigation https://www.youtube.com/watch?v=JLICaBEiJS0 https://developer.android.com/develop/ui/compose/navigation Example with Icons in Bottom Bar Application Structure sealed class Screen( val route: String, val title: String, val icon: ImageVector ) { object Home : Screen( route = \"home\", title = \"Home\", icon = Icons.Default.Home ) object Profile : Screen( route = \"profile\", title = \"Profile\", icon = Icons.Default.Person ) object Settings : Screen( route = \"settings\", title = \"Settings\", icon = Icons.Default.Settings ) companion object { val items = listOf(Home, Profile, Settings) } } Navigation Configuration @Composable fun AppNavigation() { val navController = rememberNavController() val navBackStackEntry by navController.currentBackStackEntryAsState() val currentRoute = navBackStackEntry?.destination?.route Scaffold( topBar = { TopAppBar( title = { Text(\"My Application\") } ) }, bottomBar = { NavigationBar { Screen.items.forEach { screen -> NavigationBarItem( icon = { Icon(screen.icon, contentDescription = screen.title) }, label = { Text(screen.title) }, selected = currentRoute == screen.route, onClick = { navController.navigate(screen.route) { // Avoid stacking destinations popUpTo(navController.graph.startDestinationId) { saveState = true } // Avoid multiple copies of the same destination launchSingleTop = true // Restore state when reselecting restoreState = true } } ) } } } ) { paddingValues -> NavHost( navController = navController, startDestination = Screen.Home.route, modifier = Modifier.padding(paddingValues) ) { composable(Screen.Home.route) { HomeScreen() } composable(Screen.Profile.route) { ProfileScreen() } composable(Screen.Settings.route) { SettingsScreen() } } } } Application Screens @Composable fun HomeScreen() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Icon( Icons.Default.Home, contentDescription = null, modifier = Modifier.size(48.dp) ) Spacer(modifier = Modifier.height(16.dp)) Text( \"Home Screen\", style = MaterialTheme.typography.headlineMedium ) } } @Composable fun ProfileScreen() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Icon( Icons.Default.Person, contentDescription = null, modifier = Modifier.size(48.dp) ) Spacer(modifier = Modifier.height(16.dp)) Text( \"Profile Screen\", style = MaterialTheme.typography.headlineMedium ) } } @Composable fun SettingsScreen() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Icon( Icons.Default.Settings, contentDescription = null, modifier = Modifier.size(48.dp) ) Spacer(modifier = Modifier.height(16.dp)) Text( \"Settings Screen\", style = MaterialTheme.typography.headlineMedium ) } } Important Points The NavigationBar uses NavigationBarItem for each destination The selected state is managed by comparing the current route with the item's route Navigation includes important options: launchSingleTop avoids multiple copies popUpTo with saveState properly manages the navigation stack restoreState preserves state during reselection Icons and titles are defined in the sealed Screen class currentBackStackEntryAsState() allows tracking the current destination This implementation offers smooth and intuitive navigation with a bottom navigation bar, commonly used in modern mobile applications. Users can easily switch between different sections of the application by touching the corresponding icons.","title":"14. Navigation in Jetpack Compose"},{"location":"2.%20Android/14-navigation/#14-navigation-in-jetpack-compose","text":"Git Repository","title":"14. Navigation in Jetpack Compose"},{"location":"2.%20Android/14-navigation/#example-with-buttons-to-navigate-between-composables","text":"","title":"Example with Buttons to Navigate Between Composables"},{"location":"2.%20Android/14-navigation/#initial-setup","text":"First, add the dependency in the build.gradle file: dependencies { implementation(\"androidx.navigation:navigation-compose:2.8.3\") }","title":"Initial Setup"},{"location":"2.%20Android/14-navigation/#example-structure","text":"We will create an application with three screens: Home screen Profile screen Settings screen","title":"Example Structure"},{"location":"2.%20Android/14-navigation/#route-definition","text":"sealed class Screen(val route: String) { object Home : Screen(\"home\") object Profile : Screen(\"profile\") object Settings : Screen(\"settings\") }","title":"Route Definition"},{"location":"2.%20Android/14-navigation/#screen-composable-creation","text":"@Composable fun HomeScreen(navController: NavController) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Home Screen\") Button(onClick = { navController.navigate(Screen.Profile.route) }) { Text(\"Go to Profile\") } Button(onClick = { navController.navigate(Screen.Settings.route) }) { Text(\"Go to Settings\") } } } @Composable fun ProfileScreen(navController: NavController) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Profile Screen\") Button(onClick = { navController.navigate(Screen.Settings.route) }) { Text(\"Go to Settings\") } Button(onClick = { navController.popBackStack() }) { Text(\"Back\") } } } @Composable fun SettingsScreen(navController: NavController) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Settings Screen\") Button(onClick = { navController.popBackStack() }) { Text(\"Back\") } Button( onClick = { navController.navigate(Screen.Home.route) { popUpTo(Screen.Home.route) { inclusive = true } } } ) { Text(\"Back to Home\") } } }","title":"Screen Composable Creation"},{"location":"2.%20Android/14-navigation/#navigation-configuration","text":"@Composable fun AppNavigation() { val navController = rememberNavController() NavHost( navController = navController, startDestination = Screen.Home.route ) { composable(Screen.Home.route) { HomeScreen(navController) } composable(Screen.Profile.route) { ProfileScreen(navController) } composable(Screen.Settings.route) { SettingsScreen(navController) } } }","title":"Navigation Configuration"},{"location":"2.%20Android/14-navigation/#integration-in-mainactivity","text":"class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyTheme { Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background ) { AppNavigation() } } } } }","title":"Integration in MainActivity"},{"location":"2.%20Android/14-navigation/#demonstrated-features","text":"Basic Navigation : Navigation between screens using navigate() Back Navigation : Using popBackStack() Navigation with Stack Clearing : Using popUpTo to return to home","title":"Demonstrated Features"},{"location":"2.%20Android/14-navigation/#important-points","text":"The NavController manages the navigation state The NavHost defines the navigation graph Each screen receives the NavController to manage navigation popBackStack() allows returning to the previous screen popUpTo with inclusive = true allows going back to a destination while including it in the removal This example shows the basics of navigation in Jetpack Compose while remaining simple and understandable for beginners. Citations: [1] https://proandroiddev.com/android-jetpack-compose-navigation-1cdfc488b891?gi=d31e0323b815 https://saurabhjadhavblogs.com/ultimate-guide-to-jetpack-compose-navigation https://blog.kotlin-academy.com/mastery-navigation-in-jetpack-compose-db00b0a0ef75?gi=007e50484ede https://developer.android.com/develop/ui/compose/navigation https://proandroiddev.com/mastering-navigation-in-jetpack-compose-a-guide-to-using-the-inclusive-attribute-b66916a5f15c?gi=401071494588 https://developer.android.com/codelabs/basic-android-kotlin-compose-navigation https://developer.android.com/develop/ui/compose/navigation?hl=fr https://www.youtube.com/watch?v=AIC_OFQ1r3k","title":"Important Points"},{"location":"2.%20Android/14-navigation/#example-with-menu-in-application-top-bar","text":"","title":"Example with Menu in Application Top Bar"},{"location":"2.%20Android/14-navigation/#application-structure","text":"sealed class Screen(val route: String, val title: String) { object Home : Screen(\"home\", \"Home\") object Profile : Screen(\"profile\", \"Profile\") object Settings : Screen(\"settings\", \"Settings\") }","title":"Application Structure"},{"location":"2.%20Android/14-navigation/#navigation-configuration_1","text":"@Composable fun AppNavigation() { val navController = rememberNavController() Scaffold( topBar = { TopAppBarWithMenu(navController) } ) { paddingValues -> NavHost( navController = navController, startDestination = Screen.Home.route, modifier = Modifier.padding(paddingValues) ) { composable(Screen.Home.route) { HomeScreen() } composable(Screen.Profile.route) { ProfileScreen() } composable(Screen.Settings.route) { SettingsScreen() } } } }","title":"Navigation Configuration"},{"location":"2.%20Android/14-navigation/#topbar-with-menu","text":"@Composable fun TopAppBarWithMenu(navController: NavController) { var showMenu by remember { mutableStateOf(false) } TopAppBar( title = { Text(\"My Application\") }, actions = { IconButton(onClick = { showMenu = !showMenu }) { Icon(Icons.Default.MoreVert, contentDescription = \"Menu\") } DropdownMenu( expanded = showMenu, onDismissRequest = { showMenu = false } ) { DropdownMenuItem( text = { Text(Screen.Home.title) }, onClick = { navController.navigate(Screen.Home.route) { popUpTo(Screen.Home.route) { inclusive = true } } showMenu = false } ) DropdownMenuItem( text = { Text(Screen.Profile.title) }, onClick = { navController.navigate(Screen.Profile.route) showMenu = false } ) DropdownMenuItem( text = { Text(Screen.Settings.title) }, onClick = { navController.navigate(Screen.Settings.route) showMenu = false } ) } } ) }","title":"TopBar with Menu"},{"location":"2.%20Android/14-navigation/#application-screens","text":"@Composable fun HomeScreen() { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Home Screen\") } } @Composable fun ProfileScreen() { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Profile Screen\") } } @Composable fun SettingsScreen() { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(\"Settings Screen\") } }","title":"Application Screens"},{"location":"2.%20Android/14-navigation/#important-points-to-note","text":"The menu is managed by a showMenu state that controls the DropdownMenu display Each menu item uses navController.navigate() for navigation For the home screen, we use popUpTo with inclusive = true to avoid accumulating screens in the navigation stack The Scaffold automatically manages the necessary padding to prevent content from being hidden behind the TopBar The screens are simple but can be enriched according to the application's needs This implementation offers clear and intuitive navigation via a dropdown menu in the application's top bar. Citations: https://saurabhjadhavblogs.com/ultimate-guide-to-jetpack-compose-navigation https://proandroiddev.com/android-jetpack-compose-navigation-1cdfc488b891?gi=d31e0323b815 https://proandroiddev.com/implement-bottom-bar-navigation-in-jetpack-compose-b530b1cd9ee2?gi=5c1ab6e9d027 https://proandroiddev.com/mastering-navigation-in-jetpack-compose-a-guide-to-using-the-inclusive-attribute-b66916a5f15c?gi=401071494588 https://blog.kotlin-academy.com/mastery-navigation-in-jetpack-compose-db00b0a0ef75?gi=007e50484ede https://developer.android.com/codelabs/basic-android-kotlin-compose-navigation https://www.youtube.com/watch?v=JLICaBEiJS0 https://developer.android.com/develop/ui/compose/navigation","title":"Important Points to Note"},{"location":"2.%20Android/14-navigation/#example-with-icons-in-bottom-bar","text":"","title":"Example with Icons in Bottom Bar"},{"location":"2.%20Android/14-navigation/#application-structure_1","text":"sealed class Screen( val route: String, val title: String, val icon: ImageVector ) { object Home : Screen( route = \"home\", title = \"Home\", icon = Icons.Default.Home ) object Profile : Screen( route = \"profile\", title = \"Profile\", icon = Icons.Default.Person ) object Settings : Screen( route = \"settings\", title = \"Settings\", icon = Icons.Default.Settings ) companion object { val items = listOf(Home, Profile, Settings) } }","title":"Application Structure"},{"location":"2.%20Android/14-navigation/#navigation-configuration_2","text":"@Composable fun AppNavigation() { val navController = rememberNavController() val navBackStackEntry by navController.currentBackStackEntryAsState() val currentRoute = navBackStackEntry?.destination?.route Scaffold( topBar = { TopAppBar( title = { Text(\"My Application\") } ) }, bottomBar = { NavigationBar { Screen.items.forEach { screen -> NavigationBarItem( icon = { Icon(screen.icon, contentDescription = screen.title) }, label = { Text(screen.title) }, selected = currentRoute == screen.route, onClick = { navController.navigate(screen.route) { // Avoid stacking destinations popUpTo(navController.graph.startDestinationId) { saveState = true } // Avoid multiple copies of the same destination launchSingleTop = true // Restore state when reselecting restoreState = true } } ) } } } ) { paddingValues -> NavHost( navController = navController, startDestination = Screen.Home.route, modifier = Modifier.padding(paddingValues) ) { composable(Screen.Home.route) { HomeScreen() } composable(Screen.Profile.route) { ProfileScreen() } composable(Screen.Settings.route) { SettingsScreen() } } } }","title":"Navigation Configuration"},{"location":"2.%20Android/14-navigation/#application-screens_1","text":"@Composable fun HomeScreen() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Icon( Icons.Default.Home, contentDescription = null, modifier = Modifier.size(48.dp) ) Spacer(modifier = Modifier.height(16.dp)) Text( \"Home Screen\", style = MaterialTheme.typography.headlineMedium ) } } @Composable fun ProfileScreen() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Icon( Icons.Default.Person, contentDescription = null, modifier = Modifier.size(48.dp) ) Spacer(modifier = Modifier.height(16.dp)) Text( \"Profile Screen\", style = MaterialTheme.typography.headlineMedium ) } } @Composable fun SettingsScreen() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Icon( Icons.Default.Settings, contentDescription = null, modifier = Modifier.size(48.dp) ) Spacer(modifier = Modifier.height(16.dp)) Text( \"Settings Screen\", style = MaterialTheme.typography.headlineMedium ) } }","title":"Application Screens"},{"location":"2.%20Android/14-navigation/#important-points_1","text":"The NavigationBar uses NavigationBarItem for each destination The selected state is managed by comparing the current route with the item's route Navigation includes important options: launchSingleTop avoids multiple copies popUpTo with saveState properly manages the navigation stack restoreState preserves state during reselection Icons and titles are defined in the sealed Screen class currentBackStackEntryAsState() allows tracking the current destination This implementation offers smooth and intuitive navigation with a bottom navigation bar, commonly used in modern mobile applications. Users can easily switch between different sections of the application by touching the corresponding icons.","title":"Important Points"},{"location":"2.%20Android/15-intentions/","text":"15. Intents Git Repository General Structure The code defines a main activity ( MainActivity ) that contains two Composable components to start other activities. MainActivity class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { Column { StartOtherActivity() StartOtherActivityWithValue() } } } } This is the main activity that inherits from ComponentActivity In onCreate , it defines its content with two Composable components in a Column StartOtherActivity @Composable fun StartOtherActivity() { val context = LocalContext.current Column( modifier = Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(text = \"Main Screen\") Spacer(modifier = Modifier.height(16.dp)) Button(onClick = { val intent = Intent(context, SecondActivity::class.java) context.startActivity(intent) }) { Text(\"Go to secondary screen\") } } } This component displays a title and a button When the button is clicked, it creates an Intent to start SecondActivity The Intent is an Android mechanism to start another activity StartOtherActivityWithValue @Composable fun StartOtherActivityWithValue() { val context = LocalContext.current Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Button(onClick = { val intent = Intent(context, ThirdActivity::class.java) intent.putExtra(\"buttonValue\", 1) context.startActivity(intent) }) { Text(\"Button 1\") } // Similar second button with value 2 } } This component displays two buttons Each button starts ThirdActivity passing a different value putExtra allows passing data to the next activity Important Points to Note The use of LocalContext.current to get the context needed for creating Intent The difference between a simple activity change and a change with data passing Layout organization with Column , Spacer , and modifiers for alignment The use of Jetpack Compose components ( Button , Text , etc.) Let me explain this code that represents a secondary activity in the application. SecondActivity Structure The SecondActivity Class class SecondActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { SecondScreen( onNavigateBack = { finish() } ) } } } This class inherits from ComponentActivity , like the main activity In onCreate , it defines its content with the SecondScreen component The finish() function is passed as a callback to handle returning to the previous screen finish() is an Android method that ends the current activity and returns to the previous activity The SecondScreen Component @Composable fun SecondScreen(onNavigateBack: () -> Unit) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(text = \"Secondary Screen\") Spacer(modifier = Modifier.height(16.dp)) Button(onClick = onNavigateBack) { Text(\"Return to main screen\") } } } The component takes an onNavigateBack parameter which is a lambda function with no parameters ( () -> Unit ) The interface is simple with: A \"Secondary Screen\" title A 16dp vertical space A button to return to the main screen The layout uses a Column centered horizontally and vertically The fillMaxSize() modifier makes the column occupy all available space Important Points to Note Navigation Management Back navigation is properly handled with finish() The callback is passed from activity level to Composable component Code Structure Clear separation between activity and user interface Use of reusable components Best Practices The SecondScreen component is decoupled from the activity Navigation is handled via callback rather than direct activity reference User Interface Simple and centered layout Appropriate use of spacing Clear and intuitive interface ThirdActivity Structure The ThirdActivity Class class ThirdActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val buttonValue = intent.getIntExtra(\"buttonValue\", 0) setContent { ThirdScreen( buttonValue = buttonValue, onNavigateBack = { finish() } ) } } } This activity retrieves a value passed via the Intent with getIntExtra The second parameter 0 is the default value if no value is found The retrieved value is passed to the ThirdScreen component The ThirdScreen Component @Composable fun ThirdScreen( buttonValue: Int, onNavigateBack: () -> Unit ) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(text = \"Received value: $buttonValue\") Spacer(modifier = Modifier.height(16.dp)) Button(onClick = onNavigateBack) { Text(\"Back\") } } } The component takes two parameters: buttonValue : the value received from the previous activity onNavigateBack : the callback to return to the previous screen The interface displays the received value and a back button Important Points to Note Data Passing Use of getIntExtra to retrieve the passed data Corresponds to the putExtra seen in the first file Important to specify a default value Communication Cycle The main activity sends a value The third activity retrieves it The value is displayed on screen Architecture Clear separation between logic (data retrieval) and display The Composable component remains pure and reusable String Template Use of $buttonValue to insert the value in the text Simple example of string interpolation in Kotlin This code complements the first two files well by showing how to: Receive data from another activity Display this data in the interface Maintain a clean and modular architecture","title":"15. Intents"},{"location":"2.%20Android/15-intentions/#15-intents","text":"Git Repository","title":"15. Intents"},{"location":"2.%20Android/15-intentions/#general-structure","text":"The code defines a main activity ( MainActivity ) that contains two Composable components to start other activities.","title":"General Structure"},{"location":"2.%20Android/15-intentions/#mainactivity","text":"class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { Column { StartOtherActivity() StartOtherActivityWithValue() } } } } This is the main activity that inherits from ComponentActivity In onCreate , it defines its content with two Composable components in a Column","title":"MainActivity"},{"location":"2.%20Android/15-intentions/#startotheractivity","text":"@Composable fun StartOtherActivity() { val context = LocalContext.current Column( modifier = Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(text = \"Main Screen\") Spacer(modifier = Modifier.height(16.dp)) Button(onClick = { val intent = Intent(context, SecondActivity::class.java) context.startActivity(intent) }) { Text(\"Go to secondary screen\") } } } This component displays a title and a button When the button is clicked, it creates an Intent to start SecondActivity The Intent is an Android mechanism to start another activity","title":"StartOtherActivity"},{"location":"2.%20Android/15-intentions/#startotheractivitywithvalue","text":"@Composable fun StartOtherActivityWithValue() { val context = LocalContext.current Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Button(onClick = { val intent = Intent(context, ThirdActivity::class.java) intent.putExtra(\"buttonValue\", 1) context.startActivity(intent) }) { Text(\"Button 1\") } // Similar second button with value 2 } } This component displays two buttons Each button starts ThirdActivity passing a different value putExtra allows passing data to the next activity","title":"StartOtherActivityWithValue"},{"location":"2.%20Android/15-intentions/#important-points-to-note","text":"The use of LocalContext.current to get the context needed for creating Intent The difference between a simple activity change and a change with data passing Layout organization with Column , Spacer , and modifiers for alignment The use of Jetpack Compose components ( Button , Text , etc.) Let me explain this code that represents a secondary activity in the application.","title":"Important Points to Note"},{"location":"2.%20Android/15-intentions/#secondactivity-structure","text":"","title":"SecondActivity Structure"},{"location":"2.%20Android/15-intentions/#the-secondactivity-class","text":"class SecondActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { SecondScreen( onNavigateBack = { finish() } ) } } } This class inherits from ComponentActivity , like the main activity In onCreate , it defines its content with the SecondScreen component The finish() function is passed as a callback to handle returning to the previous screen finish() is an Android method that ends the current activity and returns to the previous activity","title":"The SecondActivity Class"},{"location":"2.%20Android/15-intentions/#the-secondscreen-component","text":"@Composable fun SecondScreen(onNavigateBack: () -> Unit) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(text = \"Secondary Screen\") Spacer(modifier = Modifier.height(16.dp)) Button(onClick = onNavigateBack) { Text(\"Return to main screen\") } } } The component takes an onNavigateBack parameter which is a lambda function with no parameters ( () -> Unit ) The interface is simple with: A \"Secondary Screen\" title A 16dp vertical space A button to return to the main screen The layout uses a Column centered horizontally and vertically The fillMaxSize() modifier makes the column occupy all available space","title":"The SecondScreen Component"},{"location":"2.%20Android/15-intentions/#important-points-to-note_1","text":"Navigation Management Back navigation is properly handled with finish() The callback is passed from activity level to Composable component Code Structure Clear separation between activity and user interface Use of reusable components Best Practices The SecondScreen component is decoupled from the activity Navigation is handled via callback rather than direct activity reference User Interface Simple and centered layout Appropriate use of spacing Clear and intuitive interface","title":"Important Points to Note"},{"location":"2.%20Android/15-intentions/#thirdactivity-structure","text":"","title":"ThirdActivity Structure"},{"location":"2.%20Android/15-intentions/#the-thirdactivity-class","text":"class ThirdActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val buttonValue = intent.getIntExtra(\"buttonValue\", 0) setContent { ThirdScreen( buttonValue = buttonValue, onNavigateBack = { finish() } ) } } } This activity retrieves a value passed via the Intent with getIntExtra The second parameter 0 is the default value if no value is found The retrieved value is passed to the ThirdScreen component","title":"The ThirdActivity Class"},{"location":"2.%20Android/15-intentions/#the-thirdscreen-component","text":"@Composable fun ThirdScreen( buttonValue: Int, onNavigateBack: () -> Unit ) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Text(text = \"Received value: $buttonValue\") Spacer(modifier = Modifier.height(16.dp)) Button(onClick = onNavigateBack) { Text(\"Back\") } } } The component takes two parameters: buttonValue : the value received from the previous activity onNavigateBack : the callback to return to the previous screen The interface displays the received value and a back button","title":"The ThirdScreen Component"},{"location":"2.%20Android/15-intentions/#important-points-to-note_2","text":"Data Passing Use of getIntExtra to retrieve the passed data Corresponds to the putExtra seen in the first file Important to specify a default value Communication Cycle The main activity sends a value The third activity retrieves it The value is displayed on screen Architecture Clear separation between logic (data retrieval) and display The Composable component remains pure and reusable String Template Use of $buttonValue to insert the value in the text Simple example of string interpolation in Kotlin This code complements the first two files well by showing how to: Receive data from another activity Display this data in the interface Maintain a clean and modular architecture","title":"Important Points to Note"},{"location":"2.%20Android/16-intentions-vs-navigation/","text":"16. Intents vs. Navigation Intent vs. Navigation Navigation Compose Advantages Type safety : Compile-time checks, reducing potential errors Native integration with Jetpack Compose and modern Android architecture More readable and maintainable code , less repetitive code Declarative approach that simplifies navigation Disadvantages Limited to basic data types for navigation arguments Requires adding an additional dependency Intent Navigation Advantages Flexibility : Usable in any Android project Familiarity : Extensive documentation and community support Ability to pass Parcelable objects easily Easy integration with other Android components Disadvantages No compile-time checking : Risk of runtime errors More verbose : Requires more code for navigation management Manual management of lifecycle and state Recommendation For a new application using Jetpack Compose: Prefer Navigation Compose for internal application navigation Use Intents only for: Navigation to other applications Cases requiring passing complex objects Integration with traditional Android components This hybrid approach allows benefiting from Navigation Compose advantages while maintaining Intent flexibility when needed. Citations: https://stackoverflow.com/questions/65088035/how-to-navigate-from-a-composable-to-an-activity-in-jetpack-compose https://guides.peruzal.com/v1/android-guides/navigation/intents/ https://www.geeksforgeeks.org/start-a-new-activity-using-intent-in-android-using-jetpack-compose/ https://developer.android.com/develop/ui/compose/navigation https://developer.android.com/develop/ui/compose/navigation?hl=fr https://betterprogramming.pub/intent-based-compose-navigation-1087634b984a https://blog.kotlin-academy.com/mastery-navigation-in-jetpack-compose-db00b0a0ef75?gi=007e50484ede https://rommansabbir.com/typesafe-navigation-or-traditional-intent-passing","title":"16. Intents vs. Navigation"},{"location":"2.%20Android/16-intentions-vs-navigation/#16-intents-vs-navigation","text":"","title":"16. Intents vs. Navigation"},{"location":"2.%20Android/16-intentions-vs-navigation/#intent-vs-navigation","text":"","title":"Intent vs. Navigation"},{"location":"2.%20Android/16-intentions-vs-navigation/#navigation-compose","text":"","title":"Navigation Compose"},{"location":"2.%20Android/16-intentions-vs-navigation/#advantages","text":"Type safety : Compile-time checks, reducing potential errors Native integration with Jetpack Compose and modern Android architecture More readable and maintainable code , less repetitive code Declarative approach that simplifies navigation","title":"Advantages"},{"location":"2.%20Android/16-intentions-vs-navigation/#disadvantages","text":"Limited to basic data types for navigation arguments Requires adding an additional dependency","title":"Disadvantages"},{"location":"2.%20Android/16-intentions-vs-navigation/#intent-navigation","text":"","title":"Intent Navigation"},{"location":"2.%20Android/16-intentions-vs-navigation/#advantages_1","text":"Flexibility : Usable in any Android project Familiarity : Extensive documentation and community support Ability to pass Parcelable objects easily Easy integration with other Android components","title":"Advantages"},{"location":"2.%20Android/16-intentions-vs-navigation/#disadvantages_1","text":"No compile-time checking : Risk of runtime errors More verbose : Requires more code for navigation management Manual management of lifecycle and state","title":"Disadvantages"},{"location":"2.%20Android/16-intentions-vs-navigation/#recommendation","text":"For a new application using Jetpack Compose: Prefer Navigation Compose for internal application navigation Use Intents only for: Navigation to other applications Cases requiring passing complex objects Integration with traditional Android components This hybrid approach allows benefiting from Navigation Compose advantages while maintaining Intent flexibility when needed. Citations: https://stackoverflow.com/questions/65088035/how-to-navigate-from-a-composable-to-an-activity-in-jetpack-compose https://guides.peruzal.com/v1/android-guides/navigation/intents/ https://www.geeksforgeeks.org/start-a-new-activity-using-intent-in-android-using-jetpack-compose/ https://developer.android.com/develop/ui/compose/navigation https://developer.android.com/develop/ui/compose/navigation?hl=fr https://betterprogramming.pub/intent-based-compose-navigation-1087634b984a https://blog.kotlin-academy.com/mastery-navigation-in-jetpack-compose-db00b0a0ef75?gi=007e50484ede https://rommansabbir.com/typesafe-navigation-or-traditional-intent-passing","title":"Recommendation"},{"location":"2.%20Android/17-images-distantes/","text":"17. Displaying Remote Images and Videos Git Repository Displaying an Image from a URL in Jetpack Compose Prerequisites To display an image from a URL, we need to: Add the Coil dependency in the build.gradle file (app level) Add Internet permission in AndroidManifest.xml // build.gradle dependencies { implementation(\"io.coil-kt:coil-compose:2.5.0\") } <!-- AndroidManifest.xml --> <uses-permission android:name=\"android.permission.INTERNET\"/> Basic Composable Here's a simple usage example: import androidx.compose.foundation.layout.size import androidx.compose.runtime.Composable import androidx.compose.ui.Modifier import androidx.compose.ui.unit.dp import coil.compose.AsyncImage @Composable fun RemoteImage() { AsyncImage( model = \"https://example.com/image.jpg\", contentDescription = \"Image description\", modifier = Modifier.size(200.dp) ) } More Complete Version with Loading Management import androidx.compose.foundation.layout.* import androidx.compose.material3.CircularProgressIndicator import androidx.compose.runtime.Composable import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.layout.ContentScale import androidx.compose.ui.unit.dp import coil.compose.SubcomposeAsyncImage @Composable fun AdvancedRemoteImage() { SubcomposeAsyncImage( model = \"https://example.com/image.jpg\", contentDescription = \"Image description\", modifier = Modifier.size(200.dp), contentScale = ContentScale.Fit, loading = { Box( modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center ) { CircularProgressIndicator() } }, error = { // You can customize the error display Box( modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center ) { Text(\"Loading error\") } } ) } Important Points Coil is an image loading library for Android, optimized for Kotlin and Jetpack Compose. Two main composables are available: AsyncImage : simple version for basic cases SubcomposeAsyncImage : advanced version allowing management of loading states Main parameters: model : the image URL contentDescription : description for accessibility modifier : to customize size and appearance contentScale : to define how the image should adapt to its container For testing, here are some royalty-free image URLs: \"https://picsum.photos/200\" // Random 200x200 image \"https://via.placeholder.com/200\" // 200x200 placeholder image Complete Usage Example @Composable fun ExampleImageScreen() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp) ) { // Simple image AsyncImage( model = \"https://picsum.photos/200\", contentDescription = \"Random image\", modifier = Modifier.size(200.dp) ) // Image with loading management SubcomposeAsyncImage( model = \"https://picsum.photos/300\", contentDescription = \"Random image with loading\", modifier = Modifier.size(300.dp), loading = { CircularProgressIndicator() } ) } } Video Integration in Jetpack Compose Playing MP4 Videos with ExoPlayer To play MP4 videos, we'll use ExoPlayer, which is recommended by Google for media playback on Android. First, add the dependencies in build.gradle : dependencies { implementation(\"androidx.media3:media3-exoplayer:1.2.0\") implementation(\"androidx.media3:media3-ui:1.2.0\") } Then, create the video composable: import androidx.compose.runtime.* import androidx.compose.ui.platform.LocalContext import androidx.compose.ui.viewinterop.AndroidView import androidx.media3.common.MediaItem import androidx.media3.common.Player import androidx.media3.exoplayer.ExoPlayer import androidx.media3.ui.PlayerView @Composable fun VideoPlayer( videoUrl: String, modifier: Modifier = Modifier ) { val context = LocalContext.current // Creating ExoPlayer val exoPlayer = remember { ExoPlayer.Builder(context).build().apply { setMediaItem(MediaItem.fromUri(videoUrl)) prepare() } } // Lifecycle management DisposableEffect(Unit) { onDispose { exoPlayer.release() } } // Player user interface AndroidView( factory = { context -> PlayerView(context).apply { player = exoPlayer } }, modifier = modifier ) } Usage: @Composable fun VideoPlayerScreen() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp) ) { // Example with MP4 video VideoPlayer( videoUrl = \"https://example.com/video.mp4\", modifier = Modifier .fillMaxWidth() .aspectRatio(16f / 9f) ) } } Complete Version with Error and Loading Management @Composable fun AdvancedVideoPlayer( videoUrl: String, modifier: Modifier = Modifier ) { var isLoading by remember { mutableStateOf(true) } var hasError by remember { mutableStateOf(false) } val context = LocalContext.current val exoPlayer = remember { ExoPlayer.Builder(context).build().apply { addListener(object : Player.Listener { override fun onPlaybackStateChanged(state: Int) { when (state) { Player.STATE_READY -> isLoading = false Player.STATE_ENDED -> { /* Handle end */ } Player.STATE_BUFFERING -> isLoading = true Player.STATE_IDLE -> { /* Initial state */ } } } override fun onPlayerError(error: PlaybackException) { hasError = true isLoading = false } }) setMediaItem(MediaItem.fromUri(videoUrl)) prepare() } } DisposableEffect(Unit) { onDispose { exoPlayer.release() } } Box(modifier = modifier) { AndroidView( factory = { context -> PlayerView(context).apply { player = exoPlayer } }, modifier = Modifier.matchParentSize() ) if (isLoading) { CircularProgressIndicator( modifier = Modifier.align(Alignment.Center) ) } if (hasError) { Text( text = \"Video playback error\", modifier = Modifier.align(Alignment.Center), color = Color.Red ) } } } Important Points Add Internet permission in AndroidManifest.xml : xml <uses-permission android:name=\"android.permission.INTERNET\"/> For ExoPlayer: It's Google's recommended solution Supports many video formats Handles caching automatically Offers advanced playback controls Performance Considerations: Videos consume a lot of resources Important to properly manage lifecycle Plan for cache and bandwidth management","title":"17. Displaying Remote Images and Videos"},{"location":"2.%20Android/17-images-distantes/#17-displaying-remote-images-and-videos","text":"Git Repository","title":"17. Displaying Remote Images and Videos"},{"location":"2.%20Android/17-images-distantes/#displaying-an-image-from-a-url-in-jetpack-compose","text":"","title":"Displaying an Image from a URL in Jetpack Compose"},{"location":"2.%20Android/17-images-distantes/#prerequisites","text":"To display an image from a URL, we need to: Add the Coil dependency in the build.gradle file (app level) Add Internet permission in AndroidManifest.xml // build.gradle dependencies { implementation(\"io.coil-kt:coil-compose:2.5.0\") } <!-- AndroidManifest.xml --> <uses-permission android:name=\"android.permission.INTERNET\"/>","title":"Prerequisites"},{"location":"2.%20Android/17-images-distantes/#basic-composable","text":"Here's a simple usage example: import androidx.compose.foundation.layout.size import androidx.compose.runtime.Composable import androidx.compose.ui.Modifier import androidx.compose.ui.unit.dp import coil.compose.AsyncImage @Composable fun RemoteImage() { AsyncImage( model = \"https://example.com/image.jpg\", contentDescription = \"Image description\", modifier = Modifier.size(200.dp) ) }","title":"Basic Composable"},{"location":"2.%20Android/17-images-distantes/#more-complete-version-with-loading-management","text":"import androidx.compose.foundation.layout.* import androidx.compose.material3.CircularProgressIndicator import androidx.compose.runtime.Composable import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import androidx.compose.ui.layout.ContentScale import androidx.compose.ui.unit.dp import coil.compose.SubcomposeAsyncImage @Composable fun AdvancedRemoteImage() { SubcomposeAsyncImage( model = \"https://example.com/image.jpg\", contentDescription = \"Image description\", modifier = Modifier.size(200.dp), contentScale = ContentScale.Fit, loading = { Box( modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center ) { CircularProgressIndicator() } }, error = { // You can customize the error display Box( modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center ) { Text(\"Loading error\") } } ) }","title":"More Complete Version with Loading Management"},{"location":"2.%20Android/17-images-distantes/#important-points","text":"Coil is an image loading library for Android, optimized for Kotlin and Jetpack Compose. Two main composables are available: AsyncImage : simple version for basic cases SubcomposeAsyncImage : advanced version allowing management of loading states Main parameters: model : the image URL contentDescription : description for accessibility modifier : to customize size and appearance contentScale : to define how the image should adapt to its container For testing, here are some royalty-free image URLs: \"https://picsum.photos/200\" // Random 200x200 image \"https://via.placeholder.com/200\" // 200x200 placeholder image","title":"Important Points"},{"location":"2.%20Android/17-images-distantes/#complete-usage-example","text":"@Composable fun ExampleImageScreen() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp), verticalArrangement = Arrangement.spacedBy(16.dp) ) { // Simple image AsyncImage( model = \"https://picsum.photos/200\", contentDescription = \"Random image\", modifier = Modifier.size(200.dp) ) // Image with loading management SubcomposeAsyncImage( model = \"https://picsum.photos/300\", contentDescription = \"Random image with loading\", modifier = Modifier.size(300.dp), loading = { CircularProgressIndicator() } ) } }","title":"Complete Usage Example"},{"location":"2.%20Android/17-images-distantes/#video-integration-in-jetpack-compose","text":"","title":"Video Integration in Jetpack Compose"},{"location":"2.%20Android/17-images-distantes/#playing-mp4-videos-with-exoplayer","text":"To play MP4 videos, we'll use ExoPlayer, which is recommended by Google for media playback on Android. First, add the dependencies in build.gradle : dependencies { implementation(\"androidx.media3:media3-exoplayer:1.2.0\") implementation(\"androidx.media3:media3-ui:1.2.0\") } Then, create the video composable: import androidx.compose.runtime.* import androidx.compose.ui.platform.LocalContext import androidx.compose.ui.viewinterop.AndroidView import androidx.media3.common.MediaItem import androidx.media3.common.Player import androidx.media3.exoplayer.ExoPlayer import androidx.media3.ui.PlayerView @Composable fun VideoPlayer( videoUrl: String, modifier: Modifier = Modifier ) { val context = LocalContext.current // Creating ExoPlayer val exoPlayer = remember { ExoPlayer.Builder(context).build().apply { setMediaItem(MediaItem.fromUri(videoUrl)) prepare() } } // Lifecycle management DisposableEffect(Unit) { onDispose { exoPlayer.release() } } // Player user interface AndroidView( factory = { context -> PlayerView(context).apply { player = exoPlayer } }, modifier = modifier ) } Usage: @Composable fun VideoPlayerScreen() { Column( modifier = Modifier .fillMaxSize() .padding(16.dp) ) { // Example with MP4 video VideoPlayer( videoUrl = \"https://example.com/video.mp4\", modifier = Modifier .fillMaxWidth() .aspectRatio(16f / 9f) ) } }","title":"Playing MP4 Videos with ExoPlayer"},{"location":"2.%20Android/17-images-distantes/#complete-version-with-error-and-loading-management","text":"@Composable fun AdvancedVideoPlayer( videoUrl: String, modifier: Modifier = Modifier ) { var isLoading by remember { mutableStateOf(true) } var hasError by remember { mutableStateOf(false) } val context = LocalContext.current val exoPlayer = remember { ExoPlayer.Builder(context).build().apply { addListener(object : Player.Listener { override fun onPlaybackStateChanged(state: Int) { when (state) { Player.STATE_READY -> isLoading = false Player.STATE_ENDED -> { /* Handle end */ } Player.STATE_BUFFERING -> isLoading = true Player.STATE_IDLE -> { /* Initial state */ } } } override fun onPlayerError(error: PlaybackException) { hasError = true isLoading = false } }) setMediaItem(MediaItem.fromUri(videoUrl)) prepare() } } DisposableEffect(Unit) { onDispose { exoPlayer.release() } } Box(modifier = modifier) { AndroidView( factory = { context -> PlayerView(context).apply { player = exoPlayer } }, modifier = Modifier.matchParentSize() ) if (isLoading) { CircularProgressIndicator( modifier = Modifier.align(Alignment.Center) ) } if (hasError) { Text( text = \"Video playback error\", modifier = Modifier.align(Alignment.Center), color = Color.Red ) } } }","title":"Complete Version with Error and Loading Management"},{"location":"2.%20Android/17-images-distantes/#important-points_1","text":"Add Internet permission in AndroidManifest.xml : xml <uses-permission android:name=\"android.permission.INTERNET\"/> For ExoPlayer: It's Google's recommended solution Supports many video formats Handles caching automatically Offers advanced playback controls Performance Considerations: Videos consume a lot of resources Important to properly manage lifecycle Plan for cache and bandwidth management","title":"Important Points"}]}